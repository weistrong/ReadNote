## 方法

* **实例构造器和类(引用类型)**
    * 创建类型的实例时：
        * 1：为实例的数据字段分配内存(归零*0*或*null*)。
        * 2：初始化对象的附加字段(类型对象指针和同步块索引)。
        * 3：调用实例的构造器来设置对象的初始状态。
    * 如果类的修饰符是*abstract*，默认的构造器可访问性就是*protected*。
    * 如果类的修饰符是*static(sealed&abstact)*，不会生成默认的构造器。

* **实例构造器和结构(值类型)**
    * CLR总是允许创建值类型的实例，没有办法阻止值类型的实例化。C#不会为值类型内嵌默认的无参构造器，也不允许创建。
    * CLR允许为值类型定义构造器，但是必须显示的调用才会执行。
    * 为了生成*可验证*代码，访问值类型的任何字段之前，都需要对全部字段进行赋值。

* **类型构造器(type constructor)**
    * 别名：
        * 静态构造器（static constructor）
        * 类构造器（class constructor）
        * 类型初始化器（type initializer）
    * 只能定义一个。
    * 不能有参数。
    * 首次访问时执行。
    * 适合**单例**。
    * 只能访问类型的静态字段，通常用途就是初始化这些字段。
    * 不要在值类型中定义类型构造器，CLR有时不会调用它。

* **操作符重载方法**
    * CLR要求操作符重载方法必须时*public*和*static*方法。
    * C#要求操作符重载方法至少有一个参数的类型和当前定义这个方法的类型相同。

* **转换操作符方法**
    * CLR要求转换操作符方法必须时*public*和*static*方法。
    * C#要求参数类型和返回类型二者必有其一与定义转换方法的类型相同。
    * 用法：
        * *implicit*关键字告诉编译器为了生成代码来调用方法，不需要在源代码中进行显式转型。
        * *explicit*关键字告诉编译器只有在发生了显式转型时，才调用方法。
        * 这两个关键字之后要制定*operator*关键字表明这是个转换操作符。
        * 之后指定要转换的类型。

* **拓展方法**
    * 一些附加的规则和原则：
        * C#只支持拓展方法。不支持拓展属性、事件、操作符等。
        * 拓展方法必须在非泛型静态类中声明。至少要有一个参数，且只有第一个参数能用*this*关键字标记。
        * 静态类本身必须具有*文件作用域*。
        * 如果有人在*SomeName*命名空间中定义了一个静态类，那么必须在他的源代码文件顶部写一条*using SomeName*。
        * 谨慎使用，不要将*system.object*作为拓展方法的第一个参数。
        * 可能存在版本控制问题。如果新发布的版本包含我们自定义的拓展方法一样的原型，那么久不会调用自定义的拓展方法。

* **用拓展方法拓展各种类型**
    * 由于拓展方法实际上是对一个静态方法的调用，所以CLR不会生成代码对调用方法的表达式值进行*null*值检查。
    * 可以为**接口**类型定义拓展方法。如*IEnumerable<T>*
    * 可以为**委托**类型定义拓展方法。

* **分部方法**
    * 一些附加的规则和原则：
        * 只能在分部类或结构中声明。
        * 返回值始终是*void*，不能使用*out*修饰符。
        * 声明和实现必须具有完全一致的签名。
        * 总是被视为*private*，但编译器禁止在声明之前添加*private*关键字。
        * 如果没有对应的实现部分，便不能在代码中创建一个委托来引用这个分部方法。