## 接口

> 接口实际上相等于对一组方法签名进行了统一命名，这些方法不提供任何实现。
> 类继承的一个重要特点就是：凡是能使用具名接口类型的实例的地方，都能使用实现了接口的一个类型的实例。

* **接口定义**
  * 接口可以定义**方法**、**事件**、**无参属性**、**有参属性(索引器)**，这些本质上都是方法。
  * 接口不可以定义任何构造函数，也不能定义任何实例字段。
  * C#禁止接口定义任何一种静态成员，CLR允许。
  * CLR支持**泛型接口**和接口中的**泛型方法**。
  * 接口可从一个或多个接口继承，可以看成是将其他接口的协定(contract)包括到新接口中。

* **接口继承**
  * C#编译器要求将实现接口的方法标记为*public*。
  * CLR要求将将实现接口的方法标记为*virtual*，如果标记*virtual*，派生类能够重写它。否则，编译器会将它们标记为*virtual*和*sealed*，这会阻止派生类重写接口方法。
  * 值类型可以实现0个或多个接口，但值类型的实例转换成接口类型时必须装箱，因为接口变量是引用，必须指向堆上的对象。

* **隐式和显式接口方法实现**
  * C#中，将定义方法的那个接口的名称作为方法名前缀(IDisposable.Dispose),就会创建**显式接口方法实现(Explicit Interface Method Implementation)(EIMI)**,并且C#不允许为该方法指定可访问性，也不能标记为*virtual*，编译器会自动将其设置为*private*，只有通过接口类型的变量才能调用此。

* **泛型接口**
  * 优势：
    * 1:泛型接口提供了出色的**编译时类型安全性**，接口方法理想情况下应该使用**强类型**。
    * 2:处理值类型时装箱次数会少很多。
    * 3:类可以实现同一个接口若干次，只要每次使用不同的类型参数。
  * 接口的泛型类型参数可标记*逆变*和*协变*。

* **泛型和接口约束**
  * 优势：
    * 可将泛型类型参数约束为多个接口。实际上表示想方法传递的实参必须同时实现多个接口。
    * 传递值类型的实例时减少装箱。C#编译器为接口约束生成特殊的IL代码，导致直接在值类型上调用接口方法而不装箱。
  
* **实现多个具有相同方法名和签名的接口**
  * 