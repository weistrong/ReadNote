## 参数。

* **可选参数和命名参数**
  > 一旦为参数分配了默认值，编译器会在内部向该参数应用定制特性:*System.Runtime.InteropServices.OptionalAtttibute*和*System.Runtime.InteropServices.DefaultParameterValueAttribute*，然后向*DefaultParameterValueAttribute*的构造器传递源代码中指定的常量值。
  * 参数默认值的一些规则和原则：
    * 默认参数必须放在没有默认值的参数之后，*参数数组*例外，他必须是最后一个，并且不能有默认值。
    * 默认值必须是编译时能确定的常量值：
      * C#认定的基元类型。
      * 枚举类型。
      * 可以设为*null*的任何引用类型，可以用*default*或*new*关键字来表达这个意思，两者一致。
    * 不要重命名参数变量。
    * 如果方法从模块外部调用，考虑将默认值*0*/*null*作为哨兵值使用。
    * 如果参数有*ref*或*out*关键字，不能设置默认值。
  * 可选或命名参数的一些规则和原则：
    * 实参可按任意顺序传递，但命名实参只能出现在实参列表的尾部。
    * 可按名称将实参传给没有默认值的参数，但所有必须的实参都必须传递。
    * 不允许省略逗号之间的实参。对于有默认值的参数，如果想省略他们的实参，传递参数名即可。
    * 如果参数要求*ref/out*，为了以传参数名的方式传递参数，可以使用：
    ```
    private static void Func(ref Int32 number);
    Int32 a = 5;
    Func(number: ref a);
    ```

* **隐式类型的局部变量**
  * 不要混淆*var*和*dynamic*。*var*只能声明方法内部的局部变量并且必须显式的初始化用*var*生命的变量。*dynamic*适用于局部变量、字段和参数。

* **以传引用的方式向方法传递参数**
  * *out*和*ref*这两个关键字表示告诉CLR是以传引用而非传值的方式传递参数。
  * 为大的值类型使用*out*可以提升代码的执行效率，因为它避免了调用方法是复制值类型实例的字段。
  * 在CLR看来，*out*和*ref*是一回事：都导致传递指向实例的一个指针。
  * CLR允许根据使用的是*out*还是*ref*参数对方法进行重载，两个重载只有*out*和*ref*的区别则不合法。
  * 为值类型使用*out*和*ref*，效果等同于以传值的方式传递引用类型。
  * 对于以传引用的方式传给方法的变量，它的类型必须与方法签名中声明的类型相同。

* **向方法传递可变数量的参数**
  * *params* 只能应用于方法签名的最后一个参数。
  * *params* 只能标识一维数组(任意类型)。
  * *params* 可传递*null*值，或传递对包含零个元素的一个数组的引用。
  * *params* 对性能有所影响(除非显式传递*null*)可考虑重载：
    * 数组对象必须在堆上分配；
    * 数组元素必须初始化；
    * 数组的内存需要垃圾回收；

* **参数和返回类型的设计规范**
  * 声明方法的参数类型时，应尽量使用最弱的类型。
    * 使用*iEnumerable\<T\>*而非*List\<T\>*，使用*Stream*而非*FileStream*。
    * 更灵活、适合更广泛的情形。
  * 相反，一般最好是将方法的返回类型声明为最强的类型。