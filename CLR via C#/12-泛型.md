## 泛型

* **优势**：
  * 源代码保护。
  * 类型安全。
  * 更清晰的代码。
  * 更佳的性能。

* **开放类型和封闭类型**
  * 具有泛型类型参数的类型成为*开放类型*，CLR不允许构造开放类型的实例。
  * 代码引用泛型类型时可指定一组泛型类型实参，为所有的类型参数都传递了实际的数据类型，类型就是*封闭类型*，CLR允许构造封闭类型的实例。
  * 如果泛型类型定义了静态构造器，那么针对每个封闭类型，这个构造器都会执行一次。

* **泛型类型和继承**
  * 指定类型实参不影响继承层次结构。 

* **泛型类型同一性**
  * C#允许使用简化的语法来引用泛型封闭类型，同时不影响类型的同一性和相等性，这个语法要求在源文件顶部使用传统的*using*指令(或者使用*var*)：
    ```
    using DateTimeList = System.Collections.Generic.List<System.DateTime>;
    ```

* **代码爆炸**
  * CLR要为每种不同的方法/类型组合生成本机代码，可能造成应用程序额工作集显著增大，从而损失性能。我们将这个现象称之为：**代码爆炸**。
  * CLR的优化：
    * CLR只会为同样的类型编译一次代码。
    * CLR认为所有引用类型实参都完全相同，因为它们都是指向堆上对象的地址(32位指针/64位指针)。若实参是值类型，那么CLR就必须专门为这个值类型生成本机代码。

* **泛型委托**
  * CLR支持泛型委托，目的是保证任何类型的对象都能以类型安全的方式传给回调方法。
  * 泛型委托允许值类型实例在传给回调方法时不进行任何装箱。

* **可验证性和约束**
  * **约束**的作用是限制能指定成泛型实参的类型数量。
  * CLR不允许基于类型参数名称或约束来进行重载，只能基于元数(类型参数个数)。
  * CLR允许向类型参数应用约束，可用*一个主要约束*、*一个次要约束*以及/或者*一个构造器约束*。
    * 主要约束
      * 可指定零个或一个主要约束。
      * 指定引用类型的约束时，相等于像编译器承诺：一个指定的类型实参要么是与约束类型相同的类型，要么就是从约束类型派生额类型。
      * 有两个特殊的主要约束：
        * *class*(引用类型)
        * *struct*(值类型)
    * 次要约束
      * 可指定零个或多个次要约束。
      * 次要约束代表接口类型，这种约束向编译器承诺：类型实参实现了接口。
    * 构造器约束
      * 可指定零个或一个构造器约束。
      * 它向编译器承诺：类型实参是实现了公共*无参构造器*的非抽象类型。