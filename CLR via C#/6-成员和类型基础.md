## 类型和成员基础

#### 1、类型的可见性
* **public**
    * 任意位置可访问。
* **internal**
    * 本程序集可访问。class默认internal。
* **友元程序集**
    * 可指定程序集访问internal成员。
* **静态类**
    * 用*static*关键字定义不可实例化的类，该关键字只能应用与类，不能应用于结构(值类型)因为CLR总是允许值类型实例化。
    * **静态类的限制**
        * 静态类必须直接从基类*System.Object*派生。继承只适用于对象，而你不能创建静态类的实例。
        * 静态类不能实现任何接口，因为只有使用类的实例时，才可以调用类的接口方法。
        * 静态类中只能定义静态成员。
        * 静态类不能作为字段、方法参数或局部变量使用，因为他们都代表引用了实例的变量。
    * 使用了*static*关键字，C#编译器会将该类标记为*abstract*和*sealed*。另外，编译器不在类型中生成实例构造器方法。
* **分部类、结构和接口(partial)**
    * 由C#编译器实现，CLR对此一无所知。
    * 作用
        * 源代码控制。
        * 在同一个文件中将类或结构分解成不同的逻辑单元。
        * 代码拆分。
* **组件、多态和版本控制**
    * 版本号：2.0.1.34 （CLR不以这种方式看待版本号，只会根据依赖的版本号加载具体的程序集）
        * 主版本号(major veision)
        * 次版本号(minor veision)
        * 内部版本号(build number)
        * 修订号(revision)
    * 设计类型时应尽量减少虚方法的使用。
        * 调用虚方法的速度慢（callvirt指令）。
        * JIT编译器不能内嵌(inline)虚方法，这进一步影响性能。
        * 虚方法使组件版本控制变得困难。
        * 定义基类时，如果希望方法多态，最好是让最复杂的方法成为虚方法。
 * **合理使用类型的可见性和成员的可访问性**