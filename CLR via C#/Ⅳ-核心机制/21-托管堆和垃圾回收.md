## 托管堆和垃圾回收

> 在面向对象的环境中，每个类型都代表可供程序使用的以一种资源。要使用这些资源，必须为代表资源的类型分配内存。

#### 托管堆基础

###### 访问一个资源所需的步骤

* 调用 IL 指令 `newobj`，为代表资源的类型分配内存 _(C# new)_。
* 初始化内存，设置资源的初始状态并使资源可用。类型的实例构造器负责设置初始状态。
* 访问类型的成员来使用资源(有必要可以重复)。
* 摧毁资源的状态以进行清理。
* 释放内存(垃圾回收器独自负责)。

###### 从托管堆分配资源

> CLR 要求所有对象都从**托管堆**分配。进程初始化时，CLR 划出一个地址空间区域作为托管堆。
>
> CLR 还要维护一个指针 _(NextObjPtr)_，该指针指向下一个对象在堆中的分配位置。刚开始的时候，_NextObjPtr_ 设为地址空间区域的基地址。
>
> 一个区域被非垃圾对象填满后，CLR 会分配更多的区域。这个过程一直重复，直至整个进程地址空间都被填满。

* `new` 操作符导致 CLR 执行以下步骤：
  * 计算类型的字段（以及从基类型继承的字段）所需的字节数。
  * 加上对象的开销所需的字节数。`类型对象指针` 和 `同步块索引`。32 位程序每字段各需 32 位(共 8 字节)，64 位 double。
  * CLR 检查区域中是否有分配对象所需的字节数。
    * 如果有足够空间，就在 `NextObjPtr` 指针指向的地址处放入对象，为对象分配的字节会被清零。
    * 调用类型的构造器（为 `this` 参数传递 `NextObjPtr`），`new` 操作符返回对象引用。
    * 在返回这个引用之前，`NextObjPtr` 指针的值会加上对象占用的字节数来得到一个新值，即下个对象放入托管堆时的地址。

###### 垃圾回收算法

> 应用程序调用 new 操作符创建对象时，可能没有足够地址空间来分配该对象。发现空间不够，CLR 就执行垃圾回收。
>
> 事实上，垃圾回收是在第 **0** 代满的时候发生。

> 如果 CLR 在一次 GC 之后回收不了内存，而且进程中没有空间来分配新的 GC 区域，说明内存已经耗尽，`new` 操作符就会抛出 `OutOfMemoryException`。

> 静态字段引用的对象一直存在，知道用于加载类型的 `AppDomain` 卸载为止。
>
> 内存泄漏的一个常见原因就是让静态字段引用某个集合对象，然后不停的向集合添加数据项。静态字段使集合对象一直存活，而集合对象使所有数据项一直存活。

* **引用跟踪算法**
  * **引用计数算法** 存在问题，所以 CLR 使用一种 **引用跟踪算法**。该算法只关心引用类型的变量，因为只有这种变量才能引用堆上的对象。
  * 我们将所有引用类型的变量都成为 **根**。
* GC 流程
  * 开始 GC 时，首先暂停进程中的所有线程。
    * 防止线程在 CLR 检查期间访问对象并改变其状态。
  * 然后 CLR 进入 GC 的**标记**阶段。
    * CLR 遍历堆中的所有对象，将同步块索引字段中的一位设为 0.这表明所有对象都应删除。
  * CLR检查所有活动根，查看它们引用了哪些对象。
    * 如果一个根包含 null，CLR 忽略这个根并继续检查下一个根。
* **标记 阶段** 
  * 任何根如果引用了堆上的对象，CLR 都会标记那个对象（将其同步块索引中的位设为 1）。一个对象被标记后，CLR 会检查那个对象中的根，标记它们引用的对象。如果发现对象已经标记，就不重新检查对象的字段。避免了产生死循环。
  * 检查完毕后，所有的对象要么已标记，要么未标记。已标记的对象不能被垃圾回收，我们称这种对象是**可达 _(reachable)_** 的。未标记的对象是**不可达 _(unreachable)_**的。
* **压缩 _(compact)_ 阶段**
  * 压缩所有幸存下来的对象，使它们占用连续的内存空间。好处是：
    * 恢复了引用的 _局部化_。减小了应用程序工作集合，提升了访问这些对象时的性能。
    * 可用空间也全部是连续的。
    * 压缩意味着托管堆解决了本机（原生）堆的空间碎片化问题。
  * CLR 要从每个根减去所引用的对象在内存中便宜的字节数。保证它引用的还是以前的对象。
  * 压缩好内存后，_NextObjPtr_ 指针指向最后一个幸存对象之后的位置。
  * 压缩完成后，CLR 恢复应用程序的所有线程。

![1](21-托管堆和垃圾回收.assets/1.jpg)

![](21-托管堆和垃圾回收.assets/2.jpg)

###### 垃圾回收和调试

> 一旦根离开作用域，它引用的对象就会变得**不可达**，GC 会回收其内存。

> 使用 C#编译器的 `debug` 开关编译程序集时，编译器会应用 `System.Diagnostics.DebuggableAttribute`，并为结果程序集设置 `DebuggingModes` 的 `DisableOptimizations` 标志。运行时编译方法时，JIT 编译器看到这个标志，会将所有根的生命期延长至方法结束。



#### 代：提升性能

* CLR 的 GC 是基于**代**的垃圾回收器 _(generational garbage collector)_，它对你的代码做出了以下几点假设：
  * 对象越新，生存期越短。
  * 对象越老，生存期越长。
  * 回收堆的一部分，速度快于回收整个堆。

###### **代**的工作原理

* 如果没有回收到足够的内存，垃圾回收器会执行一次完整回收。如果还是不够，就抛出 `OutOfMemoryException` 异常。
* 这些**代**被垃圾回收时，垃圾回收器会检查有多少内存被回收，以及有多少对象幸存。基于这个结果，垃圾回收器可能增大或减小这些代的预算，以提升性能。
* 可以使用 `GCNotification` 类在第 0 代或第 2 代回收时引发一些事件。可以利用该事件在发生一次回收时响铃，计算两次回收的间隔时间，计算两次挥手之间分配了多少内存等。

###### 垃圾回收触发条件

* 最常见的是，CLR 在检测到第 0 代超过预算时触发一次 GC。
* 代码显式调用 `System.GC` 的 `Collect()` 方法（Microsoft 强烈反对）。
* Windows 报告低内存情况。
* CLR 正在卸载 AppDomain。执行涵盖所有代的垃圾回收
* CLR 正在关闭。

###### 大对象

