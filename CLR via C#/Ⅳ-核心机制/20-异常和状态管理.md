## 异常和状态管理

#### 定义异常

> 异常是指成员没有完成它的名称所宣称的行动。



####　异常处理机制

###### `try`

> 如果在一个 try 块中执行多个可能抛出同一个异常类型的操作，但不同的操作有不同的异常恢复措施，就应该将每个操作都放到它自己的 try 块中。

* 如果代码需要执行一般性的资源清理操作，需要从异常中恢复，或者两者都需要。
* 包含可能会抛出异常的代码。

###### `catch`

> 包含的是响应一个异常需要执行的代码。
>
> 一个 try 块可以关联 0 个或者多个 catch 块。
>
> Visual Studio 中调试 catch 块时，可在监视窗口中添加 `$exception` 来查看当前抛出的异常对象。

* 处理异常
  * 一旦 CLR 找到匹配的 catch 块，就会执行内层所有 finally 块中的代码。
  * 然后执行匹配异常的那个 catch 块中的代码，在这里对异常的处理通常有：
    * 重新抛出相同的异常，向调用堆栈高一层的代码通知该异常的发生；
    * 抛出一个不同的异常，向调用堆栈高一层的代码提供更加丰富的异常信息；
    * 让线程从 catch 块的底部退出_(fall out of the bottom of the catch block)_。

###### `finally`

> finally 块包含的是保证会执行的代码。一般在 finally 块中执行 try 块的行动所要求的资源清理操作。
>
> 它必须出现在 catch 块之后，并且一个 try 块最多只能够关联一个 finally 块。
>
> `Exception` 类型能捕捉 _CLS_ 和 _非CLS_异常(_System.Runtime.CompilerServices_)(CLR 2.0 以后)。



#### `System.Exception`

> CLR 允许抛出任何类型的实例，C#编译器只允许抛出 CLS 相容的异常。

###### `StackTrace` 属性

* 包含信息

  * 一个异常抛出时，CLR 在内部记录 throw 指令的位置(抛出位置)。一个 catch 块捕捉到该异常时，CLR 记录捕捉位置。

    在 catch 块内访问被抛出的异常对象的 `StackTrace` 属性，负责实现该属性的代码会调用 CLR 内部的代码。

    后者创建一个字符串来支持**从异常抛出位置到异常捕捉位置**的所有方法。

  * 抛出异常时，CLR 会重置异常起点；也就是说，CLR 只记录最新的异常对象的位置。

* 完整堆栈跟踪。

  * `StackTrace` 属性返回的字符串不包含调用堆栈中比接受异常对象的那个 catch 块高的方法。要获得从线程起始处到异常处理程序_(catch)_之间的完整堆栈跟踪，需要使用 `System.Diagnostics.StackTrace` 类型。
  
  

#### 抛出异常

* 抛出异常时要考虑两个问题：

  * 抛出什么 Exception 派生类型。
    * 要考虑调用栈中位于高出的代码，要知道那些代码如何判断一个方法失败从而执行得体的恢复代码。
  * 向异常类型的构造器传递什么字符串信息。

  

#### 定义自己的异常类

> 从 `Exception` 派生的所有类型都应该时**可序列化**的。



#### 设计规范和最佳实践

###### 善用 `finally` 块。

>  应该先用 `finally` 块清理那些已成功启动的操作，再返回至调用者或者执行 `finally` 块之后的代码。另外，还经常利用 `finally` 块显式释放对象以避免资源泄漏。

* 自动生成 `try/finally` 块的情况：
  * 只要使用了 `lock`、`using` 和 `foreach` 语句，C# 编译器就会自动生成 `try/finally` 块。
  * 重写类的析构器_( Finalize 方法)_ 时，C# 编译器也会自动生成 `try/finally` 块。

###### 不要什么都捕捉。

> 捕捉异常表明你预见到该异常，理解它为什么发生，并知道如何处理它。
>
> 换句话说，是在为应用程序定义一个**策略**。

> 不能完成任务的一个方法检测到对象状态已经损坏，而且状态无法恢复。不应抛出异常，应调用 `System.Environment` 的 `FailFast()` 方法强迫进程终止。

* 如果类型时类库的一部分，那么任何情况下都绝对不允许捕捉并“吞噬”_(自己搞定异常，并当它没有发生)_所有异常。
* 如果要在 `catch` 块中捕捉 `System.Exception` 并执行一些代码，要在 `catch` 块的末尾**重新抛出异常**。( VS 的代码之分析工具_( FxCopCmd.exe )_) 会标记包含 `catch(Exception)` 块的所有代码，除非块中有 `throw` 语句。
* 可以在一个线程中捕捉异常，在另一个线程中重新抛出异常。为此提供支持的是**异步编程模型**。

###### 得体的从异常中恢复

* 有时，调用方法时已预料到它可能抛出某些异常。可以写一些代码，允许应用程序从一场中得体地回复并继续运行。
* 捕捉具体异常时，应充分掌握在什么时候会抛出异常，并知道从捕捉的异常类型派生出了哪些具体类型。不要捕捉并处理 System.Exception，除非你会重新抛出。

###### 发生不可恢复的异常时回滚部分完成的操作-维持状态

* 为了正确回滚已部分完成的操作，代码应捕捉所有异常，并在处理完成后重新抛出。

###### 隐藏实现细节来维系协定

* 有时，需要捕捉一个异常并重新抛出不同的异常。这样做唯一的原因时维系方法的**协定**。

* 抛出的新异常应该是一个具体异常，不能是其他异常类型的基类。

* 如果捕捉一个异常并抛出新异常，目的是在异常类中添加额外的数据或上下文，可以使用:

  * ```C#
    catch(IOException e){
        e.Data.Add("FileName", fileName);
        throw;
    }
    ```



#### 未处理的异常









