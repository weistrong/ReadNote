## InnoDB行记录格式

> InnoDB 中最小的存储单位是**页**，默认每页的大小是 16KB。
>
> 页中的数据是按行进行存放的，每页中存放的行记录最少为 2 行，最多为 `16KB / 2 - 200` 行，也就是 7992 行。



#### MySQL的四种行记录格式

* **Redundant**
  
  * 以前使用的旧格式，为了兼容性一直保留。
  
* **Compact**
  
  * 自 MySQL 5.1 开始默认的行记录格式。
  
* **Dynamic**
  
  * 自 MySQL 5.7 开始默认的行记录格式。
  
* **Compressed**

  > Antelope：
  >
  > ​	先前未命名的，原始的 InnoDB文件格式，支持两种行格式：Compact 和 Redundant。MySQL 5.6 的默认文件格式。
  >
  > ​	可以与早期的版本保持最大的兼容性，不支持 Barracuda 文件格式。
  >
  > Barracuda：
  >
  > ​	新的文件格式。支持 InnoDB 的所有行格式，包括：Compressed 和 Dynamic。
  >
  > ​	这两个新的行格式相关的功能包括：InnoDB 表的压缩，长列数据的页外存储和索引。键前缀最大长度为 3072 字节。
  >
  > MySQL 5.7.9 及以后的版本中，
  >
  > 默认行格式由 `innodb_default_row_format` 变量决定，默认值是 `Dynamic`。也可以在创建表的时候指定：`ROW_FORMAT = Dynamic`。
  >
  > 如果要修改现有表的行模式为 Compressed 或 Dynamic，必须先将文件格式设置成 Barracuda：`SET GLOBAL innodb_file_format=Barracuda`。再用 `ALTER TABLEW [table_name] ROW_FORMAT=Dynamic` 修改才会生效。



#### 查看指定表的行格式

```mysql
SHOW TABLE STATUS LIKE '[table_name]'
```



#### Compact 行格式

> Compact 行记录格式是 MySQL 5.0 引入的，其设计目标是高效的存储数据。
>
> 简单来说就是：一个页中存放的行数据越多，其性能越高。

![Compact](https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007052146/2020/07/03/7we.png)



###### 变长字段长度列表

>   MySQL 支持 Varchar(m)、Text、Blob 等变长字段。变长字段存储多少字节的数据是不固定的，因此需要在存储真实数据的时候顺便将这些数据占用的字节数也存储起来。
>
>   在 Compact 行格式中，会把所有的变长字段的真实数据（非NULL）占用的字节长度存放在记录的开头，从而形成一个长度列表，各个变长字段的长度**按照列的顺序逆序存放**。

```mysql
# W:
# 某个字符集中表示一个字符最多需要使用的字节数。可通过以下命令查看：
SHOW CHATSET # 对应 MaxLen 的列的值。

# M:
# Varchat(M)，M代表该类型能够最多存储的字符个数，结合使用的字符集，可以得出该类型最多占用的字节数是：M*W。

# L:
# 表示该类型实际存储的字符串占用的字节数。
```

* 列表中每个列长度使用多少字节来表示的规则：
  * 如果 `M * W <= 255`，使用 1 个字节来表示长度。
  * 如果 `M * W > 255 && L <= 127`，使用 1 个字节来表示长度。
  * 如果 `M * W > 255 && L > 127`，使用 2 个字节来表示长度。
  * 最大不会超过两个字节。原因是 MySQL 中，对于一条记录占用的最大存储空间是有限制的，除了 Blob、Text 类型外，其它所有的列（不包含隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节，使用二进制位表示最多需要 16 为，就是 2 个字节。



###### NULL 标志位

* 该部分将每个允许为 NULL 的列都对应一个二进制位，二进制位同样按照列的顺序逆序存放。

* 二进制位为 1 表示列的值为 NULL；为 0 则表示列的值不为 NULL。
* 该部分一般占用 1 个字节，如果允许为 NULL 的字段超过了 8 个，就需要两个字节。



###### 记录头信息

* 固定占用 5 个字节：

  |     名称     | 大小 | 说明                                                         |
  | :----------: | :--: | ------------------------------------------------------------ |
  |              |  1   | 预留，未使用。                                               |
  |              |  1   | 预留，未使用。                                               |
  | delete_mask  |  1   | 记录是否被删除。                                             |
  | min_rec_mask |  1   | B+树的每层非叶子节点中的最小记录都会添加该标记。             |
  |   n_owned    |  4   | 记录拥有的记录数。                                           |
  |   heap_no    |  13  | 记录在索引堆的排序信息。                                     |
  | record_type  |  3   | 记录的类型：<br />0：普通记录。<br />1：B+树的非叶子节点。<br />2：最小记录 Infimum。<br />3：最大记录 Supremum。 |
  | next_record  |  16  | 下一条记录的相对位置。                                       |



###### 列值部分

* NULL 值只占用 NULL 标志位，不占用该部分的任何空间。

* 每行记录除了用户定义的列之外，还有三个隐藏的列：

  > 不一定存在，只有用户没有定义主键，同时也没有定义一个不能为空的 Unique 键时，InnoDB会为表默认添加一个 row_id 隐藏列作为主键。

  | 隐藏列名       | 真实名称    | 是否必须 | 占用空间（字节） | 说明             |
  | -------------- | ----------- | :------: | :--------------: | ---------------- |
  | row_id         | DB_ROW_ID   |    否    |        6         | 行ID，唯一标识。 |
  | transaction_id | DB_TRX_ID   |    是    |        6         | 事务ID。         |
  | roll_pointer   | DB_ROLL_PTR |    是    |        6         | 回滚指针。       |

#### 行溢出数据

>   已知行记录占用的空间大小最多为 65535 字节。由于每页的默认大小为 16KB，也就是 16384 字节，并且还有一条限制条件是每页需要至少存储 2 行记录（否则就失去了 B+Tree 的意义，变成链表了）。
>
>   因此很有可能会出现一页中连一条记录都存不下的情况。对于一个页中只能存储一条记录甚至一条都存不下的情况：
>
>   **InnoDB 会将占用存储空间非常大的列拆开，在当前列中存储该列的前 768 个字节的数据和一个指向溢出页（Uncompressed BLOB Page 类型）的地址。**

![行溢出](https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007052146/2020/07/04/bRg.png)

> 当一个表中只有一列，且该列的定义为：Varchat(8098) 时，正好可以存放两条记录而不会行溢出。



#### Dynamic 和 Compressed 格式

>   新的两种行记录格式对于存放在 BLOB 中的数据采用完全行溢出的方式，即连 768 个字节的数据也被移到了溢出页中，数据页（B-Tree Node）中只存放了 20 个字节的溢出页地址。
>
>   同时 Compressed 行记录格式会对行数据使用 zlib 算法进行压缩，因此在存储 BLOB、TEXT、VARCHAR 这类大长度类型的数据时比较有优势。



#### CHAR 的行结构存储

> 从 MySQL 4.1 开始，Char(N) 中的 N 指的是字符的长度而不是字节长度。这意味着：在**变长长度列表中会记录Char数据类型的长度**。对于没有占满长度还是填充 0x20。
>
> 可以认为，在多字节字符集的情况下，Char 和 Varchar 的实际行存储没有区别。