## 聚合组件

#### 聚合组件

> 可以为复杂而功能强大的 API 提供一个或多个 facade 类型来简化其使用，这对许多特性域来说都有好处。
>
> 支持面向组件的设计的 facade 称为**聚合组件_(aggregate component)_**。

> 对聚合组件来说，更重要的是提供以中更高层的抽象，而不仅仅是提供另一种做事情的方式。

* **聚合组件是一个 facade，并满足下列条件：**
  * 构造函数：应该由默认的构造函数。
  * 构造函数：构造函数的所有参数应该与属性相对应，并用来对属性进行初始化。
  * 属性：大多数属性应该有 `getter` 和 `setter`。
  * 属性：所有属性都有合理的默认值。
  * 方法：如果参数在方法调用之前不会改变，那么方法就不应该带这样的参数。这样的选项应该通过属性来指定。
  * 事件：方法不以委托为参数。所有回调函数都通过事件来实现。

###### 面向组件的设计

> 面向组件的设计_(component-oriented design)_ 是一种设计方法，它通过类型来暴露 API，而类型则由构造函数、属性、方法和事件组成。

* ~~API 设计时应该尽量不让对象处于无效状态：~~
  * ~~将所有必需的设定作为构造函数的参数。~~
  * ~~将那些在实例化后不需要改变的设定作为只读属性。~~
  * ~~把功能划分为单独的类型，是属性和方法互不交迭。~~

* 聚合组件的设计：

  * 应该隐藏细节，不需要用户关心它背后到底做了什么。
  * 应该让用户不需要事先任何接口、修改任何配置文件等。框架的设计者应该为所有接口提供默认实现，所有的配置应该有合理的默认值，而用户可以选择是否需要设定它们。
    * 除了让开发人员编写的代码更加简单之外，还应该着眼于所有必需的常见开发任务，并考虑到工具和 IDE 能够提供的特性。
    * 框架设计者应该提供完成的端到端_(end to end)_ 的解决方案，而不仅仅只是 API。
  * 聚合组件经常会实现 IComponent 或继承自一个 UI 元素类，从而与 VS 的设计器集成在一起。
* 通过清晰的异常信息来告诉用户对象正处于无效状态。
  * 异常应该在用户执行操作时抛出，而不应该在初始化组件时抛出。
  * 不要使用相反的模式来定义类_(Create-Call-Get)_。

###### 因子类型

> 聚合组建为执行常用的高层操作提供了捷径，它通常的实现方式是用一组更复杂、功能更丰富的类型组成一个 facade。我们把这些组成聚合类型的类型称为**因子类型**。

###### 聚合组件规范

* **考虑**

  * 考虑为常用的特性域提供聚合组件。
  * 考虑用事件代替需要被覆盖的虚成员。
  * 考虑让聚合组件能够自动切换状态。
    * `MessageQueue` 实例既可以接收消息，也可以发送消息，但是不应该让用户感觉到模式切换的存在。
  * 考虑将聚合组件集成到 VS 的设计器中。
  * 考虑将聚合组件和因子类型分别放入不同的程序集中。
  * 考虑把聚合组件内部的因子类型暴漏给外界访问。

* **要**

  * 要用聚合组件来对高层的概念(物理对象)进行建模，而不是对系统级的任务进行建模。
  * 要让聚合组件的名字与众所周知的系统实体相对应_(MessageQueue、Process、EventLog)_，这样能使类型更加引人注目。
  * 要在设计聚合组件时使初始化尽可能的简单。如果某一项初始化是必须的，那由于没有对组件进行初始化而引发的异常应该明确的告诉用户怎么做。
  * 要保证让聚合组件支持 Create-Set-Call 模式。
  * 要为所有的聚合组件提供默认构造函数或非常简单的构造函数。
  * 要为聚合组件提供可读写的属性来与构造函数中的所有参数相对应。
    * 用户应该始终都可以先调用默认构造函数，然后再对属性进行设置。而不是直接调用带参数的构造函数。
  * 要在聚合组件中使用事件，不要使用基于委托的 API。

* **不要**

  * 不要要求聚合组件的用户在一个场景中显式的实例化多个对象。

  * 不要要求聚合组件的用户在常用场景中使用继承、覆盖方法及实现接口。

    * 组件应该主要依靠属性及属性的组合来改变自己的行为。

  * 不要要求聚合组件的用户在常用场景中除了编写代码外，还要做其它工作。

    * 如：不应该让用户用配置文件来配置组件，也不应该让用户生成资源文件。

  * 不要设计由多种状态的因子类型。

    * 因子类型在生命期内应该只有一种状态。如 `Stream`实例表示一个已经打开的流，他要么只能读取，要么只能写入。

    