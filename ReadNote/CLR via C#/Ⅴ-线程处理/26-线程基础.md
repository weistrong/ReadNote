## 线程基础

#### Windows 为什么要支持线程

> 单线程容易堵塞程序执行。
>
> 线程的职责是对 CPU 进行虚拟化。Windows 为每个进程都提供了该进程专用的线程。

#### 线程开销

* 线程有 **时间_(内存耗用)_** 和 **时间_(运行时的执行性能)_** 上的开销。每个线程都有以下要素：
  * 线程内核对象 _(thread kernel object)_
    * 每个线程都创建，包含一组对象线程进行描述的属性。还有**线程上下文_(thread context)_**。上下文是包含 CPU 寄存器集合的内存块。对于 x86，x64，ARM 架构的线程上下文分别占用 700，1200，350 字节的内存。
  * 线程环境块 _(thread environment block, TEB)_
    * TEB 是在用户模式中分配内存和初始化内存块，TEB 耗用一个内存页 _(4KB)_。
    * TEB 包含线程的异常处理链首_(head)_。线程进入的每个 try 块都在链首插入一个节点_(node)_；线程退出 try 块时从链中删除该节点。
    * TEB 还包含线程的"线程本地存储"数据，以及由 GDI 和 OpenGL 图形使用的一些数据结构。
  * 用户模式栈 _(user-mode stack)_
    * 存储传给方法的局部变量和实参。
    * Windows 默认为每个线程的用户模式栈分配 1MB 内存（只保留，线程实际需要时才调拨物理内存）。
    * 包含一个地址，指出当前方法返回时，线程应该从什么地方接着执行。
  * 内核模式栈 _(kernel-mode stack)_
    * 应用程序代码向操作系统中的_内核模式_ 函数传递实参时使用。
    * 出于安全的考虑，针对从用户模式的代码传给内核的任何实参，Windows 都会把它们从线程的用户模式栈复制到线程的内核模式栈。一经复制，内核就可验证实参的值。由于应用程序代码不能访问内核模式栈，所以应用程序无法更改验证后的实参值。OS 内核代码开始处理复制的值。
    * 内核会调用自己内部的方法，并利用内核模式栈传递它自己的实参、存储函数的局部变量及存储返回地址。
    * 在 Windows 系统上，32 位系统占用 12KB，64位系统占用 24KB。
  * DLL 线程连接_(attach)_ 和线程分离_(detach)_ 通知。
    * Windows 的一个策略是：任何时候在进程中创建线程，都会调用进程中加载的所有托管 DLL 的 `DllMain()` 方法，并向该方法传递 DLL_THREAD_ATTACH 标志。
    * 类似的，任何时候线程终止，都会调用进程中所有非托管 DLL 的 `DllMain()` 方法，并向方法传递 DLL_THREAD_DETACH 标志。
    * 有的 DLL 需要获取这些通知，才能为进程中创建/销毁的每个线程执行特殊的初始化或(资源)清理操作。
  
* Windows 上线程的执行方式：

  * Windows 任何时刻只将一个线程分配给一个 CPU。那个线程能运行一个时间片（有时也称为_量_ 或_量程_，即_quantum_）的长度。时间片到期，Windows 就上下文切换到另一个线程。每次切换都要求 Windows 执行以下操作：
    1. 将 CPU 寄存器的值保存到当前正在运行的线程的内核对象内部的一个上下文结构中。
    2. 从现有线程集合中选出一个线程供调度。如果该线程由另一个进程拥有，Windows 在开始执行任何代码或者接触任何数据之前，还必须切换 CPU "看见"的虚拟地址空间。
    3. 将所选上下文结构中的值加载到 CPU 的寄存器中。
  * 上下文切换完成后，CPU 执行所选的线程，直到它的时间片到期。然后发生下次上下文切换。**上下文切换是净开销，应尽量避免**。
  * 进行垃圾回收时，CLR 必须挂起(暂停)所有线程，遍历它们的栈来查找根以便对堆中的对象进行标记，再次遍历它们的栈，再恢复所有线程。所以，**减少线程的数量**也会显著提升垃圾回收其的性能。
  * 每次调试遇到断点时，Windows 都会挂起正在调试的程序的所有线程，并在单步执行或者运行应用程序时恢复所有线程。所以，**线程越多，调试体验越差**。

* 优缺点：

  * 优点：使 Windows 更健壮，响应更灵敏。增强应用程序的可伸缩性。
  * 缺点：要耗用大量内存，需要相当多的时间来创建、销毁和管理。Windows 在线程之间进行上下文切换，以及发生垃圾回收时，也会浪费不少时间。

  

