## I/O 限制的异步操作（I/O Bound）

#### Windows 如何执行 I/O 操作

* 如何以异步方式执行 I/O 操作
  * 传入一个客户端请求后，服务器发出一个异步请求，此时线程不会阻塞，它可返回线程池以处理传入更多的客户端请求。
  * 服务器响应后，它的响应会进入线程池队列，使线程池线程能在某个时间处理它，最后将需要的数据发送回客户端。
  * 如果工作项被送入线程池的速度比一个线程处理它们的速度快，线程池就可能创建额外的线程。为每个 CPU 都创建一个线程。
  * 如果其中任何一个线程主动阻塞，Windows就会通知线程池它的一个线程停止运行。随后，线程池意识到 CPU 处于欠饱和状态，会创建一个新线程来替换阻塞的线程（创建线程的时间和内存开销很“贵”）。
  * 更糟的是，阻塞的线程可能醒来，CPU 又变得过饱和了，所以必须发生上下文切换。线程池这时候很聪明，线程完成处理并回到池中时，除非 CPU 再度变得饱和（刚刚饱和），否则线程池不让它们处理新的工作项。
  * 如果线程池以后判断它的线程数超过了需要的数量，会允许多余的线程终止自身。
  * 在内部，CLR 的线程池使用名为 **I/O 完成端口 _(I/O Completion Port)_** 的 Windows 资源来引出上述描述的行为。

#### C# 异步函数

> 执行异步操作是构建可伸缩、响应灵敏的应用程序的关键，它允许使用少量线程执行大量操作。
>
> 与线程池结合，异步操作允许利用机器中的所有 CPU。

```C#
private static async Task<string> IssueClientRequestAsync(){
    // something...
    await pipe.WriteAsync(request, 0, request.Length);
}
```

* 上述代码的执行方式：
  * 一旦将方法标记为 `async`，编译器就会将方法的代码转换成实现了状态机的一个状态。这就允许线程执行状态机中的一些代码并返回，方法不需要一直执行到结束。
  * `WriteAsync` 内部分配一个 Task 对象并把它返回给 IssueClientRequestAsync。
  * `await` 操作符实际会在 Task 对象上调用 ContinueWith，向它传递用于恢复状态机的方法。然后线程从 IssueClientRequestAsync 返回。
  * 将来某个时候，网络设备驱动程序会结束向管道的写入，一个线程池线程会通知 Task 对象，后者激活 ContinueWith 回调方法，造成一个线程恢复状态机。具体地说，一个线程会重新进入 IssueClientRequestAsync 方法，但会从 await 操作符的位置开始。

###### 异步方法存在以下限制：

* 不能将应用程序的 Main 方法转变成异步方法。另外，构造器、属性访问器方法和事件访问器方法不能转变成异步方法。
* 异步方法不能使用任何 out 或 ref 参数。
* 不能在 catch、finally 或 unsafe 块中使用 await 操作符。
* 不能在 await 操作符之前获得一个支持线程所有权和递归的锁，并在 await 操作符之后释放它。这是因为 await 之前的代码由一个线程执行，之后的代码则可能由另一个线程执行。在 C# lock 语句中使用 await，编译器会报错。如果显示调用 Monitor 的 Enter 和 Exit 方法，那么代码虽然能编译，但 Monitor.Exit 会在运行时抛出一个 SynchronizationLockException。
* 在查询表达式中，await 操作符只能在初始 from 子句的第一个集合表达式中使用，或者在 join 子句的集合表达式中使用。

#### 编译器如果将异步函数转换成状态机

* 编译器做了什么（异步函数的工作原理）：
  * 任何时候使用 await 操作符，编译器都会获取操作数，并尝试在它上面调用 GetAwaiter 方法。这可能是实例方法或拓展方法。返回的对象称为 awaiter_(等待者)_，正是它将被等待的对象和状态机粘合起来。
  * 状态机获得 awaiter 后，会查询其 IsCompleted 属性。
    * 如果操作已经以同步的方式完成了，属性将返回 true，而作为一项优化措施，状态机将继续执行并调用 awaiter 的 GetResult 方法。该方法要么抛异常_(操作失败)_，要么返回结果_(操作成功)_。状态机继续执行以处理结果。
    * 如果操作以异步方式完成，Iscompleted 将返回 false。状态机调用 awaiter 的 OnCompleted 方法并向它传递一个委托（引用状态机的 MoveNext 方法）。
  * 现在，状态机允许它的线程回到原地以执行其它代码。将来某个时候，封装了底层任务的 awaiter 会在完成时调用委托以执行 MoveNext。
  * 可根据状态机中的字段知道如何到达代码中的正确位置，使方法能从它当初离开的位置继续。这是，代码调用 awaiter 的 GetResult 方法。执行将从这里继续，以便对结果进行处理。

#### 异步函数拓展性

> 能用 Task 对象包装一个将来完成的操作，就可以用 await 操作符来等待该操作。

#### 异步函数和事件处理程序

> 异步函数的返回类型一般是 Task 或 Task<TResult>，它们代表函数的状态机完成。

> C# 编译器允许异步函数返回 void，这样才能利用 await 操作符执行不阻塞的 I/O 操作。编译器仍然为返回 void 的异步函数创建状态机，但不再创建 Task 对象，因为创建了也没法使用。所以，没有办法知道 void 的异步函数的状态机在什么时候运行完毕。

#### 异步函数和异常处理

* Task 对象通常抛出一个 AggregateException，可查询异常的 InnerExceptions 属性来查看具体异常信息。但将 await 用于 Task 时，抛出的是第一个内部异常而不是 AggregateException。
* 如果状态机出现未处理的异常，代表异步函数的 Task 对象会因为未处理的异常而完成。正在等待该 Task 的代码会看到异常。但异步函数也可能使用了 void 返回类型，这是调用者就没办法发现未处理的异常。所以，当返回 void 的异步函数抛出未处理的异常时，编译器生成的代码将捕捉它，并使用调用者的同步上下文重新抛出它。