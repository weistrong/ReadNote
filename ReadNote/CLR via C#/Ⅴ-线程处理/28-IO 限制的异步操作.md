## I/O 限制的异步操作（I/O Bound）

#### Windows 如何执行 I/O 操作

* 如何以异步方式执行 I/O 操作
  * 传入一个客户端请求后，服务器发出一个异步请求，此时线程不会阻塞，它可返回线程池以处理传入更多的客户端请求。
  * 服务器响应后，它的响应会进入线程池队列，使线程池线程能在某个时间处理它，最后将需要的数据发送回客户端。
  * 如果工作项被送入线程池的速度比一个线程处理它们的速度快，线程池就可能创建额外的线程。为每个 CPU 都创建一个线程。
  * 如果其中任何一个线程主动阻塞，Windows就会通知线程池它的一个线程停止运行。随后，线程池意识到 CPU 处于欠饱和状态，会创建一个新线程来替换阻塞的线程（创建线程的时间和内存开销很“贵”）。
  * 更糟的是，阻塞的线程可能醒来，CPU 又变得过饱和了，所以必须发生上下文切换。线程池这时候很聪明，线程完成处理并回到池中时，除非 CPU 再度变得饱和（刚刚饱和），否则线程池不让它们处理新的工作项。
  * 如果线程池以后判断它的线程数超过了需要的数量，会允许多余的线程终止自身。
  * 在内部，CLR 的线程池使用名为 **I/O 完成端口 _(I/O Completion Port)_** 的 Windows 资源来引出上述描述的行为。

#### C# 异步函数



