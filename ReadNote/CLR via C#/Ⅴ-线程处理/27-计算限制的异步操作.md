## 计算限制的异步操作（CPU-Bound）

#### CLR 线程池基础

> 创建、销毁、上下文切换等会浪费内存资源和对性能不利，因此，CLR 包含了代码来管理自己的线程池_(thread pool)_。
>
> 线程池是你应用程序能使用的线程集合。

* 每个 CLR 一个线程池：

  * 这个线程池由 CLR 控制的所有 AppDomain 共享。如果一个进程中加载了多个 CLR，那每个 CLR 都有它自己的线程池。

* CLR 怎么创建线程池：

  * CLR 初始化时，线程池中是没有线程的。
  * 在内部，线程池维护一个操作请求队列。
  * 应用程序执行一个异步操作时，就调用某个方法，将一个记录项_(entry)_ 追加到线程池的队列中。
  * 线程池的代码从这个队列中提取记录项，将这个方法派发_(dispatch)_ 给一个线程池线程。
  * 如果线程池中没有线程，就创建一个新线程。
  * 然后，当线程池线程完成任务后，线程不会被销毁。而是返回线程池，进入空闲状态，等待响应另一个请求。
  * 如果线程池中有大量闲置的线程，一段时间后，线程会自己醒来终止自己以释放资源。

  ```
  如果你的应用程序向线程池发出许多请求，线程池会尝试只用一个线程来服务所有请求。
  如果你发出请求的速度超过了线程池线程处理的速度，就会创建额外的线程。
  最终，你的应用程序的所有请求都能由少量线程处理。
  ```

#### 执行上下文

> 每个线程都关联一个执行上下文数据结构。
>
> 线程执行代码时，一些操作会受到线程上下文设置的影响（尤其是安全设置）。

* 执行上下文(_execution context)_包含：
  * 安全设置
    * 压缩栈。
    * Thread 的 Principal。
    * Windows 身份。
  * 宿主设置
    * System.Threading.HostExecutionContextManager
  * 逻辑调用上下文数据
    * System.Runtime.Remoting.Messageing.CallContext 的 LogicalSetData 和 LogicalGetData() 方法。
* 默认情况下，CLR 自动造成初始线程的上下文“流向“任何辅助线程，这会对应能造成一定影响。
  * 控制线程上下文如何”流向“另一个线程，使用 `ExecutionContext`。

####　协作式取消和超时

> Microsoft .NET Framework 提供了标准的**取消操作** 模式，这个模式是**协作式**的。
>
> 这意味着，要取消的操作必须显示支持取消（无论执行操作的代码，还是试图取消操作的代码，都必须使用本节提到的类型）。

* 取消操作首先要创建一个 `System.Threading.CancellationTokenSource` 对象。

* 执行一个**不允许被取消**的操作，可向该操作传递通过调用 `CancellationToken` 的静态 **None** 属性。

* 可以通过调用 `CancellationTokenSource` 的 `Register()` 方法登记一个或多个在取消一个 `CancellationTokenSource` 时调用的方法。方法需要传递的参数有：

  * 一个 Action<Object> 委托。

  * 要通过委托传给回调方法的状态值。

  * 一个 Boolean 值（名为 `useSynchronizationContext`），该值指明是否要使用调用线程的 SynchronizationContext 来调用委托。

    ```C#
    var cts = new CancellationTokenSource();
    cts.Token.Register( () => Console.WriteLine("cts is cancel!") );
    // 指定时间(1000ms)后自动取消
    cts.CancelAfter(1000);
    ```

#### 任务(Task)

> `ThreadPool.QueueUserWorkItem()` 最大的问题是没有内建的机制知道操作什么时候完成，也不能获取操作完成后的返回值。

* Task 的使用
  * 创建一个 Task，需要调用构造器并传递一个 Action 或 Action<Object> 委托，这个委托就是想执行的操作。
  * 如果传递的是期待一个 Object 的方法，还必须向 Task 的构造函数传递最终要传给操作的实参。
  * 调用 `Run()` 时，可以传递一个 Action 或 Fun<TResult> 委托来指定想要执行的操作。
  * 无论调用构造器还是 `Run()`，都可传递一个 `CancellationToken` ，它使 Task 能在调度前取消。
  * 还可向构造器传递一些 `TaskCreationOptions` 标志来**控制** Task 的执行方式。

* 异常处理
  * 如果计算限制的任务抛出未处理的异常，异常会被”吞噬“并存储到一个集合中，而线程池线程可以返回到线程池中，调用 `Wait()` 或 `Result` 时，这些成员会抛出一个 `System.AggregateException`。
  * AggregateException类型封装了异常对象的一个集合。
  * 为方便编码，AggregateException重写了 `Exception` 的 `GetBaseException()` 方法，返回作为问题根源的最内层的 AggregateException（假定集合只有一个最内层的异常）。
  * AggregateException还提供了一个 `Flatten()` 方法，它创建一个新的 AggregateException。其 `InnerExceptions` 属性包含了一个异常列表，其中的异常是通过遍历原始 AggregateException 的内层异常层次结构而生成的。
  * 最后，AggregateException 还提供了一个 `Handle()` 方法，它为 AggregateException 中包含的每个异常都调用一个回调方法。然后，回调方法可以为每个异常决定如果对其进行处理；回调返回 true 表示异常已处理。
  * 调用 `Handle()` 后，如果至少有一个异常没有处理，就创建一个新的 AggregateException 对象，其中只包含了未处理的异常，并抛出这个新的 AggregateException 对象。

```
线程调用 Wait 方法时，系统检查线程要等待的 Task 是否已经开始执行。
如果是，调用 Wait 的线程会阻塞，直到 Task 运行结束为止。
如果 Task 还没有执行，系统可能（取决于 TaskScheduler）使用调用 Wait 的线程来执行 Task。这种情况下，调用 Wait 的线程不会阻塞；它会执行 Task 并立即返回。好处在于，没有线程会被阻塞，所以减少了对资源的占用（因为不需要创建一个线程来替代被阻塞的线程），并提升了性能（因为不需要花时间创建线程，也没有上下文切换）。不好的地方在于，假如线程在调用 Wait 前已获得了一个线程同步锁，而 Task 试图获取同一个锁，就会造成死锁的线程。
```

```
如果一直不调用 Wait 或 Result，或者一直不查询 Task.Exception 属性，代码就一直注意不到这个异常的发生。
可以向 TaskScheduler 的静态 UnobservedTaskException 事件登记一个回调方法。每次当一个 Task 被垃圾回收时，如果存在一个没有被注意道德异常，CLR 的终结器线程就会引发这个事件。
一旦引发，就会像你的事件处理方法传递一个 UnobservedTaskExceptionEventArgs 对象，其中包含你没有注意到的 AggregateException。
```

###### 等待任务完成并获取结果

* 等待多个任务
  * Task 类提供了两个静态方法，允许线程等待一个 Task 对象数组：
  * `Task.WaitAny()`
    * 阻塞调用线程，知道数组中的**任何** Task 对象完成。
    * 方法返回 Int32 数组索引值，指明完成的是哪个 Task 对象。
    * 方法返回后，线程被唤醒并继续运行。
    * 如果发生超时，方法将返回 -1。
    * 如果通过一个 CancellationToken 取消，会抛出一个 OperationCanceledException。
  * `Task.WaitAll()`
    * 阻塞调用线程，知道数组中的**所有** Task 对象完成。
    * 如果所有的都完成，返回 true，发生超时则返回 false。
    * 如果通过一个 CancellationToken 取消，会抛出一个 OperationCanceledException。
  * Result 属性内部会调用 `Wait()`。

###### 取消任务

 *  机制

     *  如果 CancellationToken 在 Task 调度前取消，Task 会被取消，永远都不执行。

     *  如果 Task 已调度（通过 Start 方法），那么 Task 的代码只有显式支持取消，其操作才能在执行期间取消。

     *  虽然 Task 对象关联了一个 CancellationToken，但是没有办法访问它。因此，必须在 Task 的代码中获得创建 Task 时的同一个 CancellationToken。

     *  如果一个任务还没有开始就试图取消它，会抛出一个 InvalidOperationException。

        ```C#
        CalcellationTokenSource cts = new CalcellationTokenSource();
        Task<Int32> task = Task.Run( () => Sum(cts.Token, 100_0000_0000), cts.Token);
        ```

        

* CancellationTokenSource	
  
  * `ThrowIfCancellationRequested` 和 `IsCalcellationRequested` 的区别是如果已经取消，前者会抛出一个 OperationCanceledException 异常。

###### 任务完成时自动启动新任务

> **伸缩性**好的软件不应该使线程阻塞。调用 Wait，或者在任务尚未成功时查询任务的 Result 属性，极有可能造成线程池创建新线程。

```C#
Task<Int32> task = Task.Run( () => Sum(CalcellationToken.None, 1_0000));
Tast cwt = task.ContinueWith( task => Console.WriteLine($"The sum is: {task.Result()}") );
```

* `ContinueWith` 的使用：
  * `ContinueWith` 返回对新 Task 对象的引用_(cwt)_。
  * 可以同一个 Task 对象来多次调用 ContinueWith。
  * 任务完成时，所有 ContinueWith 任务都会进入线程池的队列中。
  * 可在调用 ContinueWith 时传递对一组 TaskContinuationOptions 枚举值进行按位 OR 运算的结果。
  * 默认情况下，新任务无论如何都会运行，不管第一个任务如何完成。
  * 一个 Task 完成时，它的所有未运行的延续任务都被自动取消。

###### 父子任务

> 除非所有的子任务（以及子任务的子任务）结束运行，否则创建任务（父任务）不认为已经结束。

```C#
Task<Int32[]> parent = new Task<Int[]32>(() => {
    var results = new Int32[2];
    
    new Task(() => results[0] = Sum(10000), TaskCreationOptions.AttachedToParent).Start();
    new Task(() => results[1] = Sum(10000), TaskCreationOptions.AttachedToParent).Start();
    
    return results;
});

parent.Start();
```

###### 任务内部揭秘

* Task 对象

  * 每个Task 对象都有一组字段，这些字段构成了任务的状态。其中包括：

    * 一个 Int32 ID（首次查询时分配，从 1 开始递增，不能自己分配）。
    * 代表 Task 执行状态的一个 Int32。
    * 对父任务的引用。
    * 对 Task 创建时指定的 TaskScheduler 的引用。
    * 对回调方法的引用。
    * 对要传给回调方法的对象的引用（Task.AsyncState）。
    * 对 ExecutionContext 的引用。
    * 对 ManualResetEventSlim 对象的引用。

  * 另外，每个 Task 对象都有对根据需要创建的补充状态的引用。补充状态包括：

    * 一个 CancellationToken。
    * 一个 ContinueWithTask 对象集合。
    * 为抛出未处理异常的子任务而准备的一个 Task 对象集合等。。。

    ``` 
    创建任务的代价就是必须为这些状态分配内存。
    如果不需要任务的附加功能，使用 ThreadPool.QueueUserWorkItem 能获得更好的资源利用率。
    ```

  * 在一个 Task 对象存在期间，可以查询 Task 的 `Status` 属性了解它在其生存期的什么位置。该属性返回一个 TaskStatus。

    ```C#
    public enum TaskStatus{
        Created,	//首次构造Task对象时。(任务已显示创建，可以手动Start()这个任务)
        WaitingForActivation,	//任务已隐式创建，会自动开始。(ContinueWith 等...)
        
        WaitingToRun,	//当任务启动时。(任务已调度，但尚未运行)
        Running,	//Task实际在一个线程上运行时。（任务正在运行）
        
        WaitingForChildrenToComplete,	//任务停止运行，并等待它的任何子任务时。
        
        // 任务的最终状态时以下三个之一
        RantoCompletion,
        Canceled,
        Faulted
    }
    
    // 判断一个任务是否完成最简单的办法：
    if (task.Status == TaskStatus.RanToCompletion) ...
    ```

    * 为了简化，Task 提供了几个只读属性：`IsCanceled` 	`IsFaulted` 	`IsCompleted`

###### 任务工厂

> 有时要创建一组共享相同配置的 Task 对象。为避免机械地将相同的参数传给每个 Task 的构造器，可创建一个任务工厂来封装通用的配置。

* `TaskFactory` `TaskFactory<TResult>`
  * 创建上述类型时，要向构造器传递工厂创建的所有任务都具有的默认值（CancellationToken、TashScheduler、TaskCreationOptions、TaskContinuationOptions）。

  ```C#
  var cts = new CancellationTokenSource();
  var tf = new TaskFactory<Int32>(
      cts.Token,
      TaskCreationOptions.AttachedToParent,
      TaskContinuationOptions.ExecuteSynchronously,
      TaskScheduler.Default);
  // 每个Task对象都共享'tf'的设置
  var childTasks = new[] {
      tf.StartNew(() => Sum(cts.Token, 10000));
      tf.StartNew(() => Sum(cts.Token, 10000));
      tf.StartNew(() => Sum(cts.Token, Int32.MaxValue));
  }
  ```

  * 无论前置任务如何完成，ContinueWhenAll 和 ContinueWhenAny 都会执行延续任务。调用这两个方法时，TaskContinuationOption 标志的以下属性是非法的：NotOnRanToCompletion、NotOnFaulted、NotOnCanceled。

###### 任务调度器

> **`TaskScheduler`** 对象负责执行被调度的任务，同时向 Visual Studio 调试器公开任务信息。

* FCL 提供了两个派生自 TaskScheduler 的类型：
  * 线程池任务调度器（thread pool task scheduler）（默认）。
    * 默认情况下，所有应用程序都是线程池任务调度器。
    * 可调用 TaskScheduler.Default 属性来获得对其的引用。
  * 同步上下文任务调度器（synchronization context task scheduler）。
    * 适合图形用户界面的应用程序。
    * 可调用 TaskScheduler.FromCurrentSynchronizationContext() 方法来获得对其的引用。

#### Parallel

> 一些常见的编程情形可通过任务提升性能。为简化编程，静态 `System.Threading.Tasks.Parallel` 类封装了这些情形，它内部使用 Task 对象。

```C#
// 不要这样处理集合中的所有项
for (Int32 i = 0; i < 1000; i++){
    DoWork(i); // 一个线程顺序执行
}
// 使用Parallel，建议使用For，执行速度更快
Parallel.For(0, 1000, i => DoWork(i)); // 线程池线程并行处理工作
Parallel.ForEach(collection, item => DoWork(i));

// 一个线程顺序执行多个方法
Parallel.Invoke(
	() => Method1();
    () => Method2();
    () => Method3());
```

* 使用 Parallel
  * 调用 Parallel 的方法有一个重要前提：工作项必须能**并行执行**。	
  * 另外要避免会修改任何共享数据的工作项，否则多个线程同时处理可能会损坏数据。解决这个问题一半是围绕数据访问添加线程同步锁。但这样一次就只能有一个线程访问数据，无法并行处理。
* 注意事项
  * Parallel 的所有方法都让调用线程参与处理。
  * Parallel 的方法本身也有开销。
    * 委托对象必须分配，而针对每个工作项都要调用一次这些委托。
    * 如果有大量可由多个线程处理的工作项，那么也许能获得性能的提升。另外，如果每一项都涉及大量工作，那么通过委托来调用所产生的性能损失可以忽略不计。
    * 如果只为了很少的几个工作项，或者为处理非常快的工作项使用 Parallel 的方法，就会得不偿失，反而降低性能。
* `For` 和 `ForEach` 方法有一些重载版本允许传递 3 个委托：
  * 任务局部初始化委托（localInit）
    * 为参与工作的每个任务都调用一次该委托，这个委托是在任务被要求处理一个工作项之前调用的。
  * 主体委托（body）
    * 为参与工作的每个线程所处理的每一项都调用一次该委托。
  * 任务局部终结委托（localFinally）
    * 为参与工作的每一个任务都调用一次该委托。这个委托是在任务处理好派发给它的所有工作项之后调用的。即使主体委托代码引发一个未处理的异常，也会调用它。

#### 并行语言集成查询（PLINQ）

> 使用 LINQ to Objects 时，只有一个线程顺利处理数据集合中的所有项，我们称之为顺序查询_(sequential query)_。要提高处理性能，可以使用并行LINQ_(Parallel LINQ)_。
>
> 它将顺序查询转换成并行查询，在内部使用 Task（排队给默认 TaskScheduler），将集合中的数据项的处理工作分散到多个 CPU 上，以便并发处理多个数据项。
>
> 和 Parallel 的方法类似，要同时处理大量项，或者每一项的处理过程都是一个耗时的计算限制的操作，那么能从并行 LINQ 获得最大的收益。

* **System.Linq.ParallelEnumerable**

  * 实现了 PLINQ 的所有功能。
  * 要调用 LINQ 方法的并行版本，必须将自己的顺序查询（基于 IEnumerable/IEnumerable<T>）转换成并行查询（基于 ParallelQuery/ParallelQuery<T>），使用 ParallelEnumerable 的 `AsParallel` 拓展方法来实现。
  * 也可以通过 ParallelEnumerable 的 `AsSequential` 方法将并行操作切换回顺序操作。

* 使用 **`ForAll()`** 来遍历查询结果，它允许多个线程同时处理结果。

  * 内部不要使用 Console.WriteLine(); 因为它内部会对线程进行同步，确保每次只有一个线程能访问控制台窗口。

* 由于 PLINQ 用多个线程处理数据项，所以数据项被并发处理，结果被无序的返回。

  * 如果要保持数据项的顺序，可调用 ParallelEnumerable 的 `AsOrdered()` 方法。
  * 调用这个方法时，线程会**成组**处理数据项，然后，这些组被合并回去，同时保持顺序。这样会损害性能。
  * 这些操作符生成不排序的操作：Distinct、Except、Intersect、Union、Join、GroupBy、GroupJoin、ToLookup。之后调用 `AsOrdered()` 方法来进行强制排序。
  * 这些操作符生成排序的操作：O人derBy、OrderByDescending、ThenBy、ThenByDescending。之后调用 `AsUnordered()` 方法来恢复不排序的结果。

* 额外的一些方法

  * `WithCancellation()`

    * 允许传递一个 CancellationToken，使查询处理能提前停止。

  * `WithDegreeOfParallelism()`

    * 指定最多允许多少个线程处理查询。默认每个内核用一个线程执行查询。
    * 可传递小于可用内核数的数字。
    * 如果查询要执行同步I/O操作，可传递比内核数大的数字，因为线程会在这些操作期间阻塞。（不要在服务器应用程序中执行同步I/O操作）

  * `WithExecutionMode()`

    * 强迫查询以并行方式处理。

    ```C#
    public enum ParallelExecutionMode {
        Default = 0,			// 让并行 LINQ 决定处理查询的最佳方式
        ForceParallelism = 1	// 强迫查询以其并行方式处理
    }
    ```

    

  * `WithMergeOptions()`

    * 控制执行结果的缓冲和合并方式。
    * 向它传递一个 ParallelMergeOptions 标志：

    ```C#
    public enum ParallelMergeOptions {
        Default = 0,		// 目前和 AutoBuffered 一样。最省内存，速度慢。
        NotBuffered = 1,	// 结果一旦就绪就开始处理。
        AutoBuffered = 2,	// 每个线程在处理前缓冲一些结果
        FullyBuffered = 3	// 每个线程在处理前缓冲所有结果。消费较多内存，速度快。
    }
    ```

    ```
    PLINQ 分析一个查询，然后决定如何更好的处理它。有时候，顺序处理一个查询可以获得更好的性能，尤其是在使用以下任何操作时：Concat、ElementAt(OrDefault)、First(OrDefault)、Last(OrDefault)、Skip(While)、Take(While)、Zip。使用 Select(Many) 或 Where 的重载版本，并向你的 selector 或 predicate 委托传递一个位置索引时也是如此。
    ```

#### 执行定时计算限制操作

> System.Threading 命名空间定义了一个 Timer 类，可用它让一个线程池线程定时调用一个方法。
>
> 构造 Timer 类的实例相当于告诉线程池：在将来的某个时间（由你指定）回调你的一个方法。
>
> 定时操作可使用 Task 的静态 Delay 方法，和 async、await 关键字。

* 执行方式
  * 线程池为所有 Timer 对象只是用一个线程。这个线程知道下一个 Timer 对象在什么时候到期（计时器还有多久触发）。下一个 Timer 对象到期时，线程就被唤醒，在内部调用 ThreadPool 的 QueueUserWorkItem，将一个工作项添加到线程池的队列中，是你的方法得到调用。
  * 如果回调方法的执行时间很长，计时器可能在上个回调还没有完成的时候再次触发。这可能造成多个线程池线程同时执行你的回调方法。为解决这个问题，建议是：构造 Timer 时，为 _period_ 参数指定 `Timout.Infinite`。这样计时器就值触发一次。然后在你的回调方法中，调用 Change 方法来指定一个新的 _dueTime_，并再次为 _period_ 参数指定 Timeout.Infinite。

* `Dispose()`
  * 允许完全取消计时器，并可在当时处于 pending 状态的所有回调完成之后，向 notifyObject 参数标识的内核对象发出信号。

```
Timer 对象被垃圾回收时，它的终结代码告诉线程池取消计时器，使它不在触发。
所以，使用 Timer 对象时，要确定有一个变量在保持 Timer 对象的存货。
```

###### FCL 中提供的几个计时器的区别：

* System.Threading 的 Timer 类

  * 要在一个线程池上执行定时的（周期性发生的）后台任务，它是最好的计时器。

* System.Timer 的 Timer 类

  * 本质上是 System.Threading.Timer 的包装类。
  * 允许在 VS 中将这些计时器对象放到设计平面上。
  * 它还公开了属性和事件，更容易使用。
  * 不建议使用。

* System.Windows.Forms 的 Timer 类

* System.Windows.Threading 的 DispatcherTimer 类

* Windows.UI.Xaml 的 DispatcherTimer 类

  * 相等于 System.Windows.Forms.Timer 类在 Windows Store 中的等价物。

  

