## 计算限制的异步操作（CPU-Bound）

#### CLR 线程池基础

> 创建、销毁、上下文切换等会浪费内存资源和对性能不利，因此，CLR 包含了代码来管理自己的线程池_(thread pool)_。
>
> 线程池是你应用程序能使用的线程集合。

* 每个 CLR 一个线程池：

  * 这个线程池由 CLR 控制的所有 AppDomain 共享。如果一个进程中加载了多个 CLR，那每个 CLR 都有它自己的线程池。

* CLR 怎么创建线程池：

  * CLR 初始化时，线程池中是没有线程的。
  * 在内部，线程池维护一个操作请求队列。
  * 应用程序执行一个异步操作时，就调用某个方法，将一个记录项_(entry)_ 追加到线程池的队列中。
  * 线程池的代码从这个队列中提取记录项，将这个方法派发_(dispatch)_ 给一个线程池线程。
  * 如果线程池中没有线程，就创建一个新线程。
  * 然后，当线程池线程完成任务后，线程不会被销毁。而是返回线程池，进入空闲状态，等待响应另一个请求。
  * 如果线程池中有大量闲置的线程，一段时间后，线程会自己醒来终止自己以释放资源。

  ```
  如果你的应用程序向线程池发出许多请求，线程池会尝试只用一个线程来服务所有请求。
  如果你发出请求的速度超过了线程池线程处理的速度，就会创建额外的线程。
  最终，你的应用程序的所有请求都能由少量线程处理。
  ```

#### 执行上下文

> 每个线程都关联一个执行上下文数据结构。

* 执行上下文(_execution context)_包含：
  * 安全设置
    * 压缩栈。
    * Thread 的 Principal。
    * Windows 身份。
  * 宿主设置
    * System.Threading.HostExecutionContextManager
  * 逻辑调用上下文数据
    * System.Runtime.Remoting.Messageing.CallContext 的 LogicalSetData 和 LogicalGetData() 方法。