## 计算限制的异步操作（CPU-Bound）

#### CLR 线程池基础

> 创建、销毁、上下文切换等会浪费内存资源和对性能不利，因此，CLR 包含了代码来管理自己的线程池_(thread pool)_。
>
> 线程池是你应用程序能使用的线程集合。

* 每个 CLR 一个线程池：

  * 这个线程池由 CLR 控制的所有 AppDomain 共享。如果一个进程中加载了多个 CLR，那每个 CLR 都有它自己的线程池。

* CLR 怎么创建线程池：

  * CLR 初始化时，线程池中是没有线程的。
  * 在内部，线程池维护一个操作请求队列。
  * 应用程序执行一个异步操作时，就调用某个方法，将一个记录项_(entry)_ 追加到线程池的队列中。
  * 线程池的代码从这个队列中提取记录项，将这个方法派发_(dispatch)_ 给一个线程池线程。
  * 如果线程池中没有线程，就创建一个新线程。
  * 然后，当线程池线程完成任务后，线程不会被销毁。而是返回线程池，进入空闲状态，等待响应另一个请求。
  * 如果线程池中有大量闲置的线程，一段时间后，线程会自己醒来终止自己以释放资源。

  ```
  如果你的应用程序向线程池发出许多请求，线程池会尝试只用一个线程来服务所有请求。
  如果你发出请求的速度超过了线程池线程处理的速度，就会创建额外的线程。
  最终，你的应用程序的所有请求都能由少量线程处理。
  ```

#### 执行上下文

> 每个线程都关联一个执行上下文数据结构。
>
> 线程执行代码时，一些操作会受到线程上下文设置的影响（尤其是安全设置）。

* 执行上下文(_execution context)_包含：
  * 安全设置
    * 压缩栈。
    * Thread 的 Principal。
    * Windows 身份。
  * 宿主设置
    * System.Threading.HostExecutionContextManager
  * 逻辑调用上下文数据
    * System.Runtime.Remoting.Messageing.CallContext 的 LogicalSetData 和 LogicalGetData() 方法。
* 默认情况下，CLR 自动造成初始线程的上下文“流向“任何辅助线程，这会对应能造成一定影响。
  * 控制线程上下文如何”流向“另一个线程，使用 `ExecutionContext`。

####　协作式取消和超时

> Microsoft .NET Framework 提供了标准的**取消操作** 模式，这个模式是**协作式**的。
>
> 这意味着，要取消的操作必须显示支持取消（无论执行操作的代码，还是试图取消操作的代码，都必须使用本节提到的类型）。

* 取消操作首先要创建一个 `System.Threading.CancellationTokenSource` 对象。

* 执行一个**不允许被取消**的操作，可向该操作传递通过调用 `CancellationToken` 的静态 **None** 属性。

* 可以通过调用 `CancellationTokenSource` 的 `Register()` 方法登记一个或多个在取消一个 `CancellationTokenSource` 时调用的方法。方法需要传递的参数有：

  * 一个 Action<Object> 委托。

  * 要通过委托传给回调方法的状态值。

  * 一个 Boolean 值（名为 `useSynchronizationContext`），该值指明是否要使用调用线程的 SynchronizationContext 来调用委托。

    ```C#
    var cts = new CancellationTokenSource();
    cts.Token.Register( () => Console.WriteLine("cts is cancel!") );
    // 指定时间(1000ms)后自动取消
    cts.CancelAfter(1000);
    ```

#### 任务(Task)

> `ThreadPool.QueueUserWorkItem()` 最大的问题是没有内建的机制知道操作什么时候完成，也不能获取操作完成后的返回值。

* Task 的使用
  * 创建一个 Task，需要调用构造器并传递一个 Action 或 Action<Object> 委托，这个委托就是想执行的操作。
  * 如果传递的是期待一个 Object 的方法，还必须向 Task 的构造函数传递最终要传给操作的实参。
  * 调用 `Run()` 时，可以传递一个 Action 或 Fun<TResult> 委托来指定想要执行的操作。
  * 无论调用构造器还是 `Run()`，都可传递一个 `CancellationToken` ，它使 Task 能在调度前取消。
  * 还可向构造器传递一些 `TaskCreationOptions` 标志来**控制** Task 的执行方式。

* 异常处理
  * 如果计算限制的任务抛出未处理的异常，异常会被”吞噬“并存储到一个集合中，而线程池线程可以返回到线程池中，调用 `Wait()` 或 `Result` 时，这些成员会抛出一个 `System.AggregateException`。
  * AggregateException类型封装了异常对象的一个集合。
  * 为方便编码，AggregateException重写了 `Exception` 的 `GetBaseException()` 方法，返回作为问题根源的最内层的 AggregateException（假定集合只有一个最内层的异常）。
  * AggregateException还提供了一个 `Flatten()` 方法，它创建一个新的 AggregateException。其 `InnerExceptions` 属性包含了一个异常列表，其中的异常是通过遍历原始 AggregateException 的内层异常层次结构而生成的。
  * 最后，AggregateException 还提供了一个 `Handle()` 方法，它为 AggregateException 中包含的每个异常都调用一个回调方法。然后，回调方法可以为每个异常决定如果对其进行处理；回调返回 true 表示异常已处理。
  * 调用 `Handle()` 后，如果至少有一个异常没有处理，就创建一个新的 AggregateException 对象，其中只包含了未处理的异常，并抛出这个新的 AggregateException 对象。

```
线程调用 Wait 方法时，系统检查线程要等待的 Task 是否已经开始执行。
如果是，调用 Wait 的线程会阻塞，直到 Task 运行结束为止。
如果 Task 还没有执行，系统可能（取决于 TaskScheduler）使用调用 Wait 的线程来执行 Task。这种情况下，调用 Wait 的线程不会阻塞；它会执行 Task 并立即返回。好处在于，没有线程会被阻塞，所以减少了对资源的占用（因为不需要创建一个线程来替代被阻塞的线程），并提升了性能（因为不需要花时间创建线程，也没有上下文切换）。不好的地方在于，假如线程在调用 Wait 前已获得了一个线程同步锁，而 Task 试图获取同一个锁，就会造成死锁的线程。
```

```
如果一直不调用 Wait 或 Result，或者一直不查询 Task.Exception 属性，代码就一直注意不到这个异常的发生。
可以向 TaskScheduler 的静态 UnobservedTaskException 事件登记一个回调方法。每次当一个 Task 被垃圾回收时，如果存在一个没有被注意道德异常，CLR 的终结器线程就会引发这个事件。
一旦引发，就会像你的事件处理方法传递一个 UnobservedTaskExceptionEventArgs 对象，其中包含你没有注意到的 AggregateException。
```

###### 等待任务完成并获取结果

* 等待多个任务
  * Task 类提供了两个静态方法，允许线程等待一个 Task 对象数组：
  * `Task.WaitAny()`
    * 阻塞调用线程，知道数组中的**任何** Task 对象完成。
    * 方法返回 Int32 数组索引值，指明完成的是哪个 Task 对象。
    * 方法返回后，线程被唤醒并继续运行。
    * 如果发生超时，方法将返回 -1。
    * 如果通过一个 CancellationToken 取消，会抛出一个 OperationCanceledException。
  * `Task.WaitAll()`
    * 阻塞调用线程，知道数组中的**所有** Task 对象完成。
    * 如果所有的都完成，返回 true，发生超时则返回 false。
    * 如果通过一个 CancellationToken 取消，会抛出一个 OperationCanceledException。
  * Result 属性内部会调用 `Wait()`。

###### 取消任务

 *  机制

     *  如果 CancellationToken 在 Task 调度前取消，Task 会被取消，永远都不执行。

     *  如果 Task 已调度（通过 Start 方法），那么 Task 的代码只有显式支持取消，其操作才能在执行期间取消。

     *  虽然 Task 对象关联了一个 CancellationToken，但是没有办法访问它。因此，必须在 Task 的代码中获得创建 Task 时的同一个 CancellationToken。

     *  如果一个任务还没有开始就试图取消它，会抛出一个 InvalidOperationException。

        ```C#
        CalcellationTokenSource cts = new CalcellationTokenSource();
        Task<Int32> task = Task.Run( () => Sum(cts.Token, 100_0000_0000), cts.Token);
        ```

        

* CancellationTokenSource	
  
  * `ThrowIfCancellationRequested` 和 `IsCalcellationRequested` 的区别是如果已经取消，前者会抛出一个 OperationCanceledException 异常。

###### 任务完成时自动启动新任务

> **伸缩性**好的软件不应该使线程阻塞。调用 Wait，或者在任务尚未成功时查询任务的 Result 属性，极有可能造成线程池创建新线程。

```C#
Task<Int32> task = Task.Run( () => Sum(CalcellationToken.None, 1_0000));
Tast cwt = task.ContinueWith( task => Console.WriteLine($"The sum is: {task.Result()}") );
```

* `ContinueWith` 的使用：
  * `ContinueWith` 返回对新 Task 对象的引用_(cwt)_。
  * 可以同一个 Task 对象来多次调用 ContinueWith。
  * 任务完成时，所有 ContinueWith 任务都会进入线程池的队列中。
  * 可在调用 ContinueWith 时传递对一组 TaskContinuationOptions 枚举值进行按位 OR 运算的结果。
  * 默认情况下，新任务无论如何都会运行，不管第一个任务如何完成。
  * 一个 Task 完成时，它的所有未运行的延续任务都被自动取消。

###### 父子任务

> 除非所有的子任务（以及子任务的子任务）结束运行，否则创建任务（父任务）不认为已经结束。

```C#
Task<Int32[]> parent = new Task<Int[]32>(() => {
    var results = new Int32[2];
    
    new Task(() => results[0] = Sum(10000), TaskCreationOptions.AttachedToParent).Start();
    new Task(() => results[1] = Sum(10000), TaskCreationOptions.AttachedToParent).Start();
    
    return results;
});

parent.Start();
```

###### 任务内部揭秘

* Task 对象

  * 每个Task 对象都有一组字段，这些字段构成了任务的状态。其中包括：

    * 一个 Int32 ID（首次查询时分配，从 1 开始递增，不能自己分配）。
    * 代表 Task 执行状态的一个 Int32。
    * 对父任务的引用。
    * 对 Task 创建时指定的 TaskScheduler 的引用。
    * 对回调方法的引用。
    * 对要传给回调方法的对象的引用（Task.AsyncState）。
    * 对 ExecutionContext 的引用。
    * 对 ManualResetEventSlim 对象的引用。

  * 另外，每个 Task 对象都有对根据需要创建的补充状态的引用。补充状态包括：

    * 一个 CancellationToken。
    * 一个 ContinueWithTask 对象集合。
    * 为抛出未处理异常的子任务而准备的一个 Task 对象集合等。。。

    ``` 
    创建任务的代价就是必须为这些状态分配内存。
    如果不需要任务的附加功能，使用 ThreadPool.QueueUserWorkItem 能获得更好的资源利用率。
    ```

  * 在一个 Task 对象存在期间，可以查询 Task 的 `Status` 属性了解它在其生存期的什么位置。该属性返回一个 TaskStatus。

    ```C#
    public enum TaskStatus{
        Created,	//首次构造Task对象时。(任务已显示创建，可以手动Start()这个任务)
        WaitingForActivation,	//任务已隐式创建，会自动开始。(ContinueWith 等...)
        
        WaitingToRun,	//当任务启动时。(任务已调度，但尚未运行)
        Running,	//Task实际在一个线程上运行时。（任务正在运行）
        
        WaitingForChildrenToComplete,	//任务停止运行，并等待它的任何子任务时。
        
        // 任务的最终状态时以下三个之一
        RantoCompletion,
        Canceled,
        Faulted
    }
    
    // 判断一个任务是否完成最简单的办法：
    if (task.Status == TaskStatus.RanToCompletion) ...
    ```

    * 为了简化，Task 提供了几个只读属性：`IsCanceled` 	`IsFaulted` 	`IsCompleted`

###### 任务工厂

> 有时要创建一组共享相同配置的 Task 对象。为避免机械地将相同的参数传给每个 Task 的构造器，可创建一个任务工厂来封装通用的配置。

* `TaskFactory` `TaskFactory<TResult>`
  * 创建上述类型时，要向构造器传递工厂创建的所有任务都具有的默认值（CancellationToken、TashScheduler、TaskCreationOptions、TaskContinuationOptions）。

  ```C#
  var cts = new CancellationTokenSource();
  var tf = new TaskFactory<Int32>(
      cts.Token,
      TaskCreationOptions.AttachedToParent,
      TaskContinuationOptions.ExecuteSynchronously,
      TaskScheduler.Default);
  // 每个Task对象都共享'tf'的设置
  var childTasks = new[] {
      tf.StartNew(() => Sum(cts.Token, 10000));
      tf.StartNew(() => Sum(cts.Token, 10000));
      tf.StartNew(() => Sum(cts.Token, Int32.MaxValue));
  }
  ```

  * 无论前置任务如何完成，ContinueWhenAll 和 ContinueWhenAny 都会执行延续任务。调用这两个方法时，TaskContinuationOption 标志的以下属性是非法的：NotOnRanToCompletion、NotOnFaulted、NotOnCanceled。

###### 任务调度器

> **`TaskScheduler`** 对象负责执行被调度的任务，同时向 Visual Studio 调试器公开任务信息。

* FCL 提供了两个派生自 TaskScheduler 的类型：
  * 线程池任务调度器（thread pool task scheduler）（默认）。
    * 默认情况下，所有应用程序都是线程池任务调度器。
    * 可调用 TaskScheduler.Default 属性来获得对其的引用。
  * 同步上下文任务调度器（synchronization context task scheduler）。
    * 适合图形用户界面的应用程序。
    * 可调用 TaskScheduler.FromCurrentSynchronizationContext() 方法来获得对其的引用。

#### Parallel

> 一些常见的编程情形可通过任务提升性能。为简化编程，静态 `System.Threading.Tasks.Parallel` 类封装了这些情形，它内部使用 Task 对象。

```C#
// 不要这样处理集合中的所有项
for (Int32 i = 0; i < 1000; i++){
    DoWork(i); // 一个线程顺序执行
}
// 使用Parallel，建议使用For，执行速度更快
Parallel.For(0, 1000, i => DoWork(i)); // 线程池线程并行处理工作
Parallel.ForEach(collection, item => DoWork(i));

// 一个线程顺序执行多个方法
Parallel.Invoke(
	() => Method1();
    () => Method2();
    () => Method3());
```

* 使用 Parallel
  * 调用 Parallel 的方法有一个重要前提：工作项必须能**并行执行**。	
  * 另外要避免会修改任何共享数据的工作项，否则多个线程同时处理可能会损坏数据。解决这个问题一半是围绕数据访问添加线程同步锁。但这样一次就只能有一个线程访问数据，无法并行处理。
* 注意事项
  * Parallel 的所有方法都让调用线程参与处理。
  * Parallel 的方法本身也有开销。
    * 委托对象必须分配，而针对每个工作项都要调用一次这些委托。
    * 如果有大量可由多个线程处理的工作项，那么也许能获得性能的提升。另外，如果每一项都涉及大量工作，那么通过委托来调用所产生的性能损失可以忽略不计。
    * 如果只为了很少的几个工作项，或者为处理非常快的工作项使用 Parallel 的方法，就会得不偿失，反而降低性能。
* `For` 和 `ForEach` 方法有一些重载版本允许传递 3 个委托：
  * 任务局部初始化委托（localInit）
    * 为参与工作的每个任务都调用一次该委托，这个委托是在任务被要求处理一个工作项之前调用的。
  * 主体委托（body）
    * 为参与工作的每个线程所处理的每一项都调用一次该委托。
  * 任务局部终结委托（localFinally）
    * 为参与工作的每一个任务都调用一次该委托。这个委托是在任务处理好派发给它的所有工作项之后调用的。即使主体委托代码引发一个未处理的异常，也会调用它。

#### 并行语言集成查询（PLINQ）

> 使用 LINQ to Objects 时，只有一个线程顺利处理数据集合中的所有项，我们称之为顺序查询_(sequential query)_。要提高处理性能，可以使用并行LINQ_(Parallel LINQ)_。
>
> 