## 基元线程同步构造

> 一个线程池线程阻塞时，线程池会创建额外的线程。而创建、销毁和调度线程所需的时间和内存相当昂贵。为了构建可伸缩、响应灵敏的程序，关键在于不要阻塞你的线程，使它们能用于（和重用于）执行其它任务。

####　线程同步

* **线程同步**
  * 多个线程**同时**访问共享数据时，线程同步能防止数据损坏。之所以要强调**同时**，是因为线程同步问题其实就是计时问题。
  * 如果一些数据由两个线程访问，但那些线程不可能同时接触到数据，就完全用不着线程同步。
  * 根据异步函数的实现方式，不可能有两个线程同时访问相同的数据，所以，在代码访问异步函数中包含的数据时不需要线程同步。
* 线程同步存在的问题：
  * **比较繁琐，容易写错**
    * 代码中必须标识出所有可能由多个线程同时访问的数据。然后必须用额外的代码将这些代码包裹起来，并获取和释放一个线程同步锁。
    * 锁的作用是确保一次只有一个线程访问资源。只要有一个代码块忘记用锁包围，数据就会损坏。
    * 没有办法证明已正确添加了所有锁定代码，只能进行大量压力测试（应该在 CPU 多的机器上测试，CPU 越多，多个线程同时访问资源的几率越大）。
  * **损害性能**
    * 释放和获取锁都需要时间，因为要调用一些额外的方法。
    * 不同的 CPU 必须协调，以决定哪个线程先取得锁，让 CPU 以这种方式通信，会对性能造成影响。
  * **一次只允许一个线程访问资源**
    * 这是锁的全部意义所在，也是问题所在，因为阻塞一个线程会造成更多的线程被创建。
    * 当阻塞的线程再次运行时，它会和新的线程池线程共同运行，Windows 现在要调度比 CPU 数量更多的线程，这会增大上下文切换的纪律，进一步损坏性能。
* 尽可能的避免进行线程同步：
  * 避免使用像静态字段这样的共享数据。
  * 可试着使用值类型，因为它们总是被复制。
  * 多个线程同时对共享数据进行只读访问是没有任何问题的。

#### 类库和线程安全

* **线程安全**
  * 使一个方法线程安全，并不是说它一定要在内部获取一个线程同步锁。线程安全的方法意味着在两个线程试图同时访问数据时，数据不会被破坏。
  * FCL 保证**所有的静态方法**都是线程安全的。
  * FCL 不保证**实例方法**都是线程安全的（如果实例方法的目的是协调线程，则实例方法应该是线程安全的）。
    * 如：一个线程可能调用 CancellationTokenSource 的 Cancel 方法取消一个操作，另一个线程通过查询对应的 IsCancellationRequested 属性，检测到它应该停止正在做的事情。这两个实例成员内部通过一个特殊的线程_(两个成员访问的字段被标记为**volatile**)_同步代码来协调两个线程。

#### 基元用户模式和内核模式构造

* **基元_(primitive)_**
  * 基元是指可以在代码中使用的最简单的构造。有两种基元构造：
    * 内核模式_(kernel-mode)_
    * 用户模式_(user-mode)_
    * 将线程从这两个模式相互切换时会招致巨大的性能损失，这正是为什么要避免使用内核模式构造的原因。
* **用户模式（尽量使用）**
  * 优点：
    * 它们的速度要显著快于内核模式的构造。因为它们使用了特殊 CPU 指令来协调线程。
    * 意味着协调是在硬件中发生，这也意味着 Windows 操作系统永远检测不到一个线程在基元用户模式的构造上阻塞了。由于在用户模式的基元构造上阻塞的相处超线程永远不认为有阻塞，所以线程池不会创建新线程来替换这种临时阻塞的线程。此外，这些 CPU 指令只阻塞线程相当短的时间。
  * 缺点：
    * 只有 Windows 操作系统内核才能停止一个线程的运行（防止它浪费 CPU 时间）。
    * 在用户模式中运行的线程可能被系统抢占_(preempted)_，但线程会以最快的速度再次调度。
    * 所以，想要取得资源但暂时取不到的线程会一直在用户模式中"自旋_(忙等待 Spinning)_"。这可能浪费大量 CPU 时间。
* **内核模式**
  * 内核模式的构造是由 Windows 操作系统自身提供的。所以，它们要求在应用程序的线程中调用由操作系统内核实现的函数。
  * 优点：线程通过内核模式的构造获取其他线程拥有的资源时，Windows 会阻塞线程以避免它浪费 CPU 时间。当资源变得可用时，Windows 会恢复线程，允许它访问资源。
* **活锁 - 死锁**
  * 对于在一个构造上等待的线程，如果拥有这个构造的线程一直不是释放它，前者就可能一直阻塞。如果是用户模式的构造，线程将一直在一个 CPU 上运行，我们称为 `活锁`。
  * 如果是内核模式构造的线程，线程将一直阻塞，我们称为 `死锁`。
  * 两者都不好，但两者之间，死锁总是优于活锁，因为活锁既浪费 CPU 时间，又浪费内存（线程栈等），而死锁之浪费内存。
* **混合构造**
  * 在没有竞争的情况下，快且不会阻塞，如果存在对构造的竞争，被操作系统内核阻塞。

#### 用户模式构造

* 原子性
  * CLR 保证对以下数据类型的变量读写是原子性的：
    * Boolean、Char、(S)Byte、(U)Int16、(U)Int32、(U)IntPtr、Single 以及引用类型。
    * 查询其它类型时不同线程可能获取的不是相同值，这称为一次 **torn read**。
    * 虽然对变量的原子访问可以保证读写操作一次性完成，但由于编译器和 CPU 的优化，不保证操作什么时候发生。
    * 本章**基元用户模式构造**用于规划好这些原子性读写操作的时间。此外，这些构造还可强制对 Double、(U)Int64 类型的变量进行原子性、规划好时间的访问。
* 有两种基元用户模式线程同步构造：
  * **易变构造_(volatile construct)_**
    * 在特定的时间，它在包含一个简单数据类型的变量上执行原子性的**读或写**操作。
  * **互锁构造_(interlocked construct)_**
    * 在特定的时间，他在包含一个简单数据类型的变量上执行原子性的**读和写**操作。
  * 所有易变和互锁构造都要求传递对包含简单数据类型的一个变量的引用_(内存地址)_。

