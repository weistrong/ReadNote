## 基元线程同步构造

> 一个线程池线程阻塞时，线程池会创建额外的线程。而创建、销毁和调度线程所需的时间和内存相当昂贵。为了构建可伸缩、响应灵敏的程序，关键在于不要阻塞你的线程，使它们能用于（和重用于）执行其它任务。

####　线程同步

* **线程同步**
  * 多个线程**同时**访问共享数据时，线程同步能防止数据损坏。之所以要强调**同时**，是因为线程同步问题其实就是计时问题。
  * 如果一些数据由两个线程访问，但那些线程不可能同时接触到数据，就完全用不着线程同步。
  * 根据异步函数的实现方式，不可能有两个线程同时访问相同的数据，所以，在代码访问异步函数中包含的数据时不需要线程同步。
* 线程同步存在的问题：
  * **比较繁琐，容易写错**
    * 代码中必须标识出所有可能由多个线程同时访问的数据。然后必须用额外的代码将这些代码包裹起来，并获取和释放一个线程同步锁。
    * 锁的作用是确保一次只有一个线程访问资源。只要有一个代码块忘记用锁包围，数据就会损坏。
    * 没有办法证明已正确添加了所有锁定代码，只能进行大量压力测试（应该在 CPU 多的机器上测试，CPU 越多，多个线程同时访问资源的几率越大）。
  * **损害性能**
    * 释放和获取锁都需要时间，因为要调用一些额外的方法。
    * 不同的 CPU 必须协调，以决定哪个线程先取得锁，让 CPU 以这种方式通信，会对性能造成影响。
  * **一次只允许一个线程访问资源**
    * 这是锁的全部意义所在，也是问题所在，因为阻塞一个线程会造成更多的线程被创建。
    * 当阻塞的线程再次运行时，它会和新的线程池线程共同运行，Windows 现在要调度比 CPU 数量更多的线程，这会增大上下文切换的纪律，进一步损坏性能。
* 尽可能的避免进行线程同步：
  * 避免使用像静态字段这样的共享数据。
  * 可试着使用值类型，因为它们总是被复制。
  * 多个线程同时对共享数据进行只读访问是没有任何问题的。

#### 类库和线程安全

* **线程安全**
  * 使一个方法线程安全，并不是说它一定要在内部获取一个线程同步锁。线程安全的方法意味着在两个线程试图同时访问数据时，数据不会被破坏。
  * FCL 保证**所有的静态方法**都是线程安全的。
  * FCL 不保证**实例方法**都是线程安全的（如果实例方法的目的是协调线程，则实例方法应该是线程安全的）。
    * 如：一个线程可能调用 CancellationTokenSource 的 Cancel 方法取消一个操作，另一个线程通过查询对应的 IsCancellationRequested 属性，检测到它应该停止正在做的事情。这两个实例成员内部通过一个特殊的线程_(两个成员访问的字段被标记为**volatile**)_同步代码来协调两个线程。

#### 基元用户模式和内核模式构造

* **基元_(primitive)_**
  * 基元是指可以在代码中使用的最简单的构造。有两种基元构造：
    * 内核模式_(kernel-mode)_
    * 用户模式_(user-mode)_
    * 将线程从这两个模式相互切换时会招致巨大的性能损失，这正是为什么要避免使用内核模式构造的原因。
* **用户模式（尽量使用）**
  * 优点：
    * 它们的速度要显著快于内核模式的构造。因为它们使用了特殊 CPU 指令来协调线程。
    * 意味着协调是在硬件中发生，这也意味着 Windows 操作系统永远检测不到一个线程在基元用户模式的构造上阻塞了。由于在用户模式的基元构造上阻塞的相处超线程永远不认为有阻塞，所以线程池不会创建新线程来替换这种临时阻塞的线程。此外，这些 CPU 指令只阻塞线程相当短的时间。
  * 缺点：
    * 只有 Windows 操作系统内核才能停止一个线程的运行（防止它浪费 CPU 时间）。
    * 在用户模式中运行的线程可能被系统抢占_(preempted)_，但线程会以最快的速度再次调度。
    * 所以，想要取得资源但暂时取不到的线程会一直在用户模式中"自旋_(忙等待 Spinning)_"。这可能浪费大量 CPU 时间。
* **内核模式**
  * 内核模式的构造是由 Windows 操作系统自身提供的。所以，它们要求在应用程序的线程中调用由操作系统内核实现的函数。
  * 优点：线程通过内核模式的构造获取其他线程拥有的资源时，Windows 会阻塞线程以避免它浪费 CPU 时间。当资源变得可用时，Windows 会恢复线程，允许它访问资源。
* **活锁 - 死锁**
  * 对于在一个构造上等待的线程，如果拥有这个构造的线程一直不是释放它，前者就可能一直阻塞。如果是用户模式的构造，线程将一直在一个 CPU 上运行，我们称为 `活锁`。
  * 如果是内核模式构造的线程，线程将一直阻塞，我们称为 `死锁`。
  * 两者都不好，但两者之间，死锁总是优于活锁，因为活锁既浪费 CPU 时间，又浪费内存（线程栈等），而死锁之浪费内存。
* **混合构造**
  * 在没有竞争的情况下，快且不会阻塞，如果存在对构造的竞争，被操作系统内核阻塞。

#### 用户模式构造

* 原子性
  * CLR 保证对以下数据类型的变量读写是原子性的：
    * Boolean、Char、(S)Byte、(U)Int16、(U)Int32、(U)IntPtr、Single 以及引用类型。
    * 查询其它类型时不同线程可能获取的不是相同值，这称为一次 **torn read**。
    * 虽然对变量的原子访问可以保证读写操作一次性完成，但由于编译器和 CPU 的优化，不保证操作什么时候发生。
    * 本章**基元用户模式构造**用于规划好这些原子性读写操作的时间。此外，这些构造还可强制对 Double、(U)Int64 类型的变量进行原子性、规划好时间的访问。
* 有两种基元用户模式线程同步构造：
  * **易变构造_(volatile construct)_**
    * 在特定的时间，它在包含一个简单数据类型的变量上执行原子性的**读或写**操作。
  * **互锁构造_(interlocked construct)_**
    * 在特定的时间，他在包含一个简单数据类型的变量上执行原子性的**读和写**操作。
  * 所有易变和互锁构造都要求传递对包含简单数据类型的一个变量的引用_(内存地址)_。

###### 易变构造

* `System.Threading.Volatile`
  * `Volatile.Write()` 方法强迫 location 中的值在调用时写入。此外，按照编码顺序，之前的加载和存储操作必须在调用 `Volatile.Write()` 之前发生。
  * `Volatile.Read()` 方法强迫 location 中的值在调用时读取，此外，按照编码顺序，之前的加载和存储操作必须在调用 `Volatile.Read()` 之后发生。
  * **当线程通过共享内存相互通信时，调用 `Volation.Write` 来写入最后一个值，调用 `Volation.Read()` 来读取第一个值。** 
* C# 对易变字段的支持
  * C# 编译器提供了 `volatile` 关键字，它可应用于：
    * 可用于一下任何类型的静态或实例字段：
      * `Boolean`、`(S)Byte`、`(U)Int16`、`(U)Int32`、`(U)IntPtr`、`Single`、`Char`。
    * 引用类型的字段。
    * 基础类型为：`(S)Byte`、`(U)Int16`、`(U)Int32`的任意枚举字段。
  * volatile 关键字告诉 C# 和 JIT 编译器不将字段缓存到 CPU 的寄存器中，确保字段的所有读写操作都是在 RAM 中进行。
  * C# 不支持以传引用的方式将 volatile 字段传给方法。

###### 互锁构造

* **`System.Threading.Interlocked`**
  * Interlocked 类中的每个方法都执行一次原子读取以及写入操作。
  * Interlocked  类的所有方法都建立了完成的内存栅栏_(memory fence)_：
    * 调用某个 Interlocked 方法之前的任何变量写入都在这个 Interlocked 方法调用之前执行。
    * 这个调用之后的任何变量读取都在这个调用之后读取。

###### 实现简单的自旋锁_(spin lock)_

> Interlocked 主要用于操作 Int32 值。
>
> 如果需要原子性的操作类对象中的一组字段，需要采取一个办法阻止所有线程，只允许其中一个进入对字段进行操作的代码区域。
>
> 可以使用 Interlocked 的方法构造一个线程同步块。

```C#
internal struct SimpleSpinLock{
    private Int32 m_ResourceInUse; //0=false(默认) 1=true    
    public void Enter(){
        while(true){
            if(Interlocked.Exchange(ref m_ResourceInUser, 1) == 0) return;
            // 这里添加'黑科技'
        }
    }    
    public void Leave(){
        Interlocked.Exchange(ref m_REsourceInUser, 0);
    }
}
```

```C#
public sealed class SomeResource{
    private SimpleSpinLock m_s1 = new SimpleSpinLock();
    public void AccessResource(){
        m_s1.Enter();
        // 一次只有一个线程才能进入这里访问资源...
        m_s1.Leave();
    }
}
```

* “自旋”造成 CPU 的浪费。所以只应该用于保护那些会执行得非常快的代码区域。

* Windows 有时会短时间地动态提升一个线程的优先级，因此，单 CPU 中对于正在使用自旋锁的线程，应该禁止像这样的优先级提升。

* 超线程机器同样存在自旋锁的问题，为了解决这个问题，许多自旋锁内部都有一些额外的逻辑_(黑科技)_。
  
  * FCL 提供了名为 `System.Threading.SpinWait` 的结构，它封装了关于 _黑科技_ 的最新研究成果。
  
* **_黑科技_** 旨在让希望获得资源的线程暂停执行，使当前拥有资源的线程能执行它的代码并让出资源。为此，SpinWait 结构内部调用 Thread 的静态 `Sleep()`、`Yield()` 和 `SpinWait()` 方法，

  * `Thread()`
    * 这个方法导致线程在指定时间内挂起。允许线程资源放弃它的时间片的剩余部分，系统会使线程在**大致**指定的时间里不被调度。
    * 传递参数 System.Threading.Timeout.Infinite _(-1)_，可以告诉系统永远不调度线程，但这样做没有意义。
    * 传递 0，告诉系统调用线程放弃了它当前时间片的剩余部分，强迫系统调用另一个线程。但系统可能重新调度该线程（如果没有相同或更高优先级的其它可调度线程）。
  * `Yield()`
    * 方法可以实现：线程要求 Windows 在当前 CPU 上调度另一个线程。
    * 如果 Windows 发现有另一个线程准备好运行，Yield 就返回 true，调用 Yield 的线程会提前结束它的时间片，所选的线程得以运行一个时间片。
    * 然后，调用 Yield 的线程被再次调度，开始用一个全新的时间片运行。
    * 如果 Windows 没有发现其他线程准备在当前处理器上运行，Yield 就返回 false，调用 Yield 的线程继续运行它的时间片。
    * 调用 Yield 的效果介于 Sleep(0) _(不允许较低优先级的线程运行)_ 和 Sleep(1) _(总是强迫进行上下文切换)_ 之间。
  * `SpinWait()`
    * 超线程CPU 一次只允许一个线程运行，在这些 CPU 上执行自旋循环时，需要强迫当前线程暂停，使 CPU 有机会切换到另一个线程并允许它运行。线程可调用 Thread  的 SpinWait 方法强迫它自身暂停，允许超线程CPU 切换到另一个线程。
    * 调用这个方法实际会执行一个特殊的 CPU指令：它不告诉 Windows 做任何事情（因为 Windows 已经认为它在 CPU 上调度了两个线程）。

  ###### Interlocked Anything 模式

  



