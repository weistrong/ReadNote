## 数组

> CLR支持**一维**、**二维**和**交错数组**。所有的数组类型都隐式从 `System.Array` 派生，后者又从 `System.Object` 派生。所以数组都是引用类型，在托管堆上分配空间。在应用程序的变量或字段中，保存的是对数组的引用。

#### 数组转型

> 对于元素为**引用类型**的数组，CLR允许将数组元素从一种类型转型另一种。
>
> 成功转型要求数组维数相同，而且必须存在从元素源类型到目标类型的隐式或显式转换。

* `Array.Copy()`

  * 作用是将元素从一个数组复制到另一个。
  * 能正确处理内存的重叠区域。
  * 能在复制每个数组元素的时候进行必要的类型转换：
    * 将值类型的元素装箱为引用类型的元素；`Int32[] -> Object[]`
    * 将引用类型的元素拆箱为值类型的元素；`Object[] -> Int32[]`
    * 加宽CLR基元值类型；`Int32[] -> Double[]`
    * 在两个数组之间进行复制时，如果仅从数组类型证明不了两者的兼容性，就根据需要对元素进行向下类型转换。 

* `System.Array.BlockCopy()`

  > 将一个数组的元素可靠的复制到另一个数组。

  * 该方法要么完成复制，要么抛出异常，不会破坏目标数组中的数据。
  * 要求源数组的元素类型要么与目标数组的元素类型相同，要么派生自目标数组的元素类型。
  * 它不执行任何装箱、拆箱或向下类型转换。

* 数组的协变性

  * 有时需要将数组从一种类型转换为另一种类型，这种功能叫做**数组协变性_(array covariance)_**。
  * 利用它时要注意由此带来的性能损失。

* `System.Buffer.BlockCopy()`

  > 如果只是需要将数组的部分元素复制到另一个数组，建议使用 `System.Buffer.BlockCopy()` 方法。

  * 比 `Array.Copy()` 快。
  * 只支持基元类型。
  * 没有转型能力。
  * 方法的Int32参数代表的是数组中的字节偏移量。

#### 所有数组都隐式派生自 `System.Array`

> 可以调用 `System.Array` 定义的所有实例方法和属性。

#### 所有数组都隐式实现 `IEnumerable` 、`ICollection` 和 `IList`

> 如果数组包含值类型的元素，数组类型不会为元素的基类型实现接口。
>
> 这是因为值类型的数组和引用类型的数组在内存中的布局不同。

#### 数组的传递和返回

> 数组作为实参传给方法时，实际传递的是对数组的引用。因此，被调用的方法能够修改数组中的元素。如果不想被修改，必须生成数组的拷贝(深拷贝)并将拷贝传递给方法。

> 将方法设计返回对含有0个元素的一个数组的引用，而不是返回null，可以更方便的调用(不需要执行null值检测)。

#### 创建下限非零的数组

> 创建和操作下限非零的数组，可以使用数组的 `CreateInstance()` 静态方法来动态的创建自己的数组。

#### 数组的内部工作原理

* CLR内部支持两种不同的数组：
  * 下限为0的一维数组。或称为_SZ(single-dimensional, zero-based,一维0基)_数组_ 或 _向量(vector)_。
  * 下限未知的一维或多维数组。
* 0基数组的执行更快：
  * 因为循环时他只在第一次判断数组中元素的合法性。
* C#和CLR允许使用 `unsafe` 代码访问数组，这时将不会执行索引上下限检查。
  * 功能强大，但使用需谨慎，因为它允许直接访问内存，访问越界不会抛出异常。可能会损坏内存中的数据，破坏类型安全性。
  * 使用该技术有三点不足：
    * 相较于其他技术，处理数组元素的代码更复杂，不容易读和写，因为要使用C# fixed语句，要执行内存地址计算。
    * 计算过程中出错，可能访问到不属于数组的内存。这会造成计算错误，破坏内存数据，破坏类型安全性，并可能造成安全漏洞。
    * 因为这些潜在的问题，CLR禁止在降低了安全级别的环境(如Microsoft silverlight)中运行不安全代码。

#### 不安全的数组访问和固定大小的数组

> 如果性能是首要目标，就要避免在堆上分配托管的数组对象。使用C#的 `stackalloc` 语句可以在线程栈上分配数组。
>
> `stackalloc` 语句只能创建一维0基、由值类型元素构成的数组，而且值类型绝对不能包含任何引用类型的字段。
>
> 使用这个功能要为C#编译器指定/unsafe开关。