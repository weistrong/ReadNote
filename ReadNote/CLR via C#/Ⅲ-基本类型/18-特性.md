## 特性

> 利用定制特性，可宣告式的为自己的代码构造添加注解来实现特殊功能。定制特性允许为几乎每一个元数据表记录项定义和应用信息。这种可拓展的元数据信息能在运行时查询，从而动态改变代码的执行方式。

> 它们只是将一些附加信息与某个目标元素关联起来的方式，编译器在托管模块的元数据中生成(嵌入)这些额外的信息。

#### 使用定制特性

* C#允许将特性应用于定义一下任何目标元素的源代码，并且允许用一个前缀明确指定特性要应用于的目标元素。

  |              目标元素              |   前缀   | 是否必须 | 是否可继承*(Inherited)* |
  | :--------------------------------: | :------: | :------: | :---------------------: |
  |               程序集               | assembly |  **Y**   |            N            |
  |                模块                |  module  |  **Y**   |            N            |
  | 类型（类、结构、枚举、接口、委托） |   type   |    N     |        **Y(类)**        |
  |                字段                |  field   |    N     |          **Y**          |
  |          方法（含构造器）          |  method  |    N     |          **Y**          |
  |              方法参数              |  param   |    N     |          **Y**          |
  |             方法返回值             |  return  |  **Y**   |          **Y**          |
  |                属性                | property |    N     |          **Y**          |
  |                事件                |  event   |    N     |            N            |
  |            泛型类型参数            | typevar  |    N     |          **Y**          |

#### 定义特性类

```C#
namespace System{
    [AttributeUsage(AttributeTargets.Enum, Inherited = false)]
    public class FlagsAttribute : System.Attributes{
        public FlagsAttribute(){ }
    }
}
```

* `AttributeTargets.Enum`
  * 告诉编译器这个特性的合法应用范围。
* `Inherited`
  * 指出特性在应用于基类时，是否同时应用于派生类和重写的方法。

#### 特性构造器和字段/属性数据类型

> 定制特性类可定义构造器来获取参数。开发人员在应用特性类的实例时必须指定这些参数。
>
> 还可在类中定义非静态公共字段和属性，使开发人员能为特性类的实例选择恰当的位置。

* 定制特性类的实例构造器、字段、属性时，可选的数据类型：

  * `Boolean` `Char` `Byte` `SByte` `Int16` `UInt16` `Ing32` `UInt32` `Int64` `UInt64` `Single` `Double` `String` `Type` `Object`
  * 还可使用上述任意类型的**一维0基数组**。
  * 应尽量避免使用数组，因为对于定制特性，如果它的构造器要获取数组作为参数，就会失去与CLS的相容性。
* 应用特性时必须传递一个编译时常量表达式。

#### 检测定制特性

* 如果只想判断目标是否应用了一个特性，使用 `IsDefined()` 方法更高效。使用 `IsDefined()` 不会构造特性对象，不会调用构造器，也不会设置字段和属性。
* 要构造特性对象，必须调用 `GetCustomAttributes()` 和 `GetCustomAttribute()` 方法。每次调用这两个方法时，都会构造指定特性类型的新实例，并根据源代码中指定的值来设置每个实例的字段和属性。两个方法都返回对完全构造号的特性类实例的引用。

|      方法名称       | 说明                                                         |
| :-----------------: | ------------------------------------------------------------ |
|      IsDefined      | 如果至少有一个指定的 `Attribute` 派生类的实例与目标关联，就返回 `true`。这个方法效率很高，因为他不构造(反序列化)特性类的任何实例。 |
| GetCustomAttributes | 返回应用于目标的指定特性对象的集合。每个实例都是用编译时指定的参数、字段和属性来构造(反序列化)。如果目标没有应用指定特性类的实例，就返回一个空集合。该方法通常用于已将 `AllowMultiple` 设为 `true` 的特性，或者用于列出一应用的所有特性。 |
| GetCustomAttribute  | 返回应用于目标的指定特性类的实例。实例使用编译时指定的参数、字段和属性来构造(反序列化)。如果目标没有应用给指定特性类的实例，就返回 `null`。如果目标应用了指定特性的多个实例，就抛出 `System.Reflection.AmbiguousMatchException` 异常。该方法通常用于已将 `AllowMultiple` 设为 `false` 的特性。 |

> **调用上述任何方法，内部都必须扫描托管模块的元数据，执行字符串比较来定位指定的定制特性类。如果对性能要求高，考虑缓存这些方法的调用结果。**

#### 两个特性实例的相互匹配

> 如何判断是否向目标应用了一个特性的实例，`System.Attrubute` 重写了 `Object` 的 `Equals` 方法，会在内部比较两个对象的类型。不一致会返回 `false` 。如果一致，`Equals` 会利用反射来比较两个特性对象中的字段值(为每个字段都调用 `Equals`)。所有字段都匹配就返回 `true`，否则返回 `false`。
>
> 可在自己的定制特性类中重写 `Equals` 来移除反射的使用，从而提升性能。

#### 条件特性类

> 应用了 `System.Diagnostics.ConditionalAttribute` 的特性类称为**条件特性类**。

> 当含有目标元素的代码编译时，只有在定义 `TEST` 和 `VERIFT` 符号的前提下，编译器才会在元数据中生成特性信息。不过，特性类的定义元数据和实现仍存在于程序集中。

