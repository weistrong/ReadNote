## 基元类型、引用类型和值类型

#### 1、基元类型。
> 编译器直接支持的数据类型成为 *基元类型*。直接映射到Framework类库(FLC)中存在的类型。

* **建议直接使用FCL名称。**
* **类型转换：**
    * 只有在安全（不会发生数据丢失）的时候C#才允许隐式类型转换。
    * 转换时，C#总是对结果进行截断，而不是进行向上取整。
* **checked 和 unchecked：**
    * CLR内部提供一些关于类型转换的指令：*add/add.ovf* *sub/sub.ovf* *mul/mul.ovf* *conv/conv.ovf*
    * *溢出检查* 默认关闭。
    * 如果进行 *checked*，因为需要检查这些运算是否发生溢出，执行会稍慢一些。
    * 控制溢出可以使用 */checked+* 编译器开关。
            Byte b = checked((Byte) 200)); 
            checked {
                Byte b = checked((Byte) 200));
            }
            //OverflowException 异常
```
总结： 
* 尽量使用有符号数值类型。
* 使用vs的*/checked+* 开关及性能调试行生成。发布时使用*/checked-*。
* Decimal是特殊的类型。CLR不将其视为基元类型。Decimal值的处理速度慢于CLR基元类型的值。如果对Decimal只执行的运算是不安全的，一定抛出异常。
```


#### 2、引用类型和值类型
> 如果所有类型都是引用类型，那么每次使用都进行一次内存分配，性能会受到很大的影响。

* **值类型**
    * 所有称之为**结构或枚举**的都是值类型。
    * 值类型在线程栈上分配。实例中不包含指向治理的指针而是实例本身。
    * 值类型不受垃圾回收器的控制，缓解了托管堆的压力，减少了应用程序生存期内的垃圾回收次数。
    
* **引用类型**
    * 所有称之为**类**的都是引用类型。
    * 内存必须从托管堆上分配。
    * 堆上分配的每个对象都有一些额外成员，这些成员必须初始化。
    * 对象中的其他字节（为字段而设）总是设为零。
    * 从托管堆上分配对象是，可能强制进行一次垃圾回收。
    
* **区别**
    * 值类型对象有**未装箱**和**已装箱**两种形式，引用类型总是**已装箱**形式。
    * 值类型从*System.ValueType* 派生，该类重写了System.Object的*Equals*和*GetHashCode*方法，由于这个默认实现有性能问题，所以定义自己的值类型是应重写这两个方法，并提供他们的显示实现。
    * 值类型不能作为基类型来定义新的值类型或新的引用类型，所以不应该在值类型中引入任何新的虚方法和抽象方法，所有方法都隐式密封（不可重写）。
    * 应用类型的变量包含堆中对象的地址，创建时默认为null，表示当前不指向任何有效对象，试图使用会抛异常。值类型总是包含其基础类型的一个值，不会抛异常。除非添加可空标识(nullability)。
    * 值类型复制是逐字段的复制，引用类型复制是复制内存地址。所以，对一个变量执行操作，引用类型可能应用到另一个变量引用的对象，而值类型则不会。
    * 未装箱的值类型不再活动，为他们分类的存储就会被释放，而不是等着垃圾回收。
    
* **装箱和拆箱**
    * 装箱：
        * 在托管堆中分配内存，内存大小是该类型个字段和两个额外成员所需的内存量。
        * 将值类型的字段复制到新分配的堆内存。
        * 返回对象地址。
    * 拆箱
        * 获取已装箱实例在堆中的地址。
        * 将改值从托管堆复制到线程栈中。
    * 注意
        * 对对象进行拆箱时，只能转型为最初未装箱的值类型。
        * Int32.ToString() 不发生装箱，因为他调用的时System.ValueType的ToString()。
        * 如果确定自己的代码会造成编译器反复对一个值类型进行装箱，请改成手动方式对值类型进行装。

* **对象相等性和同一性**
    * *Object.Equals* 判断的时对象的 *同一性(identity)*，而不是*相等性(equality)*。
    * 检查同一性务必调用*Object.ReferenceEquals*。
    * 定义自己的值类型时，因为System.ValueType的Equals利用反射机制，执行慢。应该重写*Equals*方法。重写的方法要符合相等性的4个特征：
        * 必须自反。x.Equals(x)肯定返回true。
        * 必须对称。x.Equals(y)和y.Equals(x)返回相同的值。
        * 必须可传递。x.Equals(y)和 y.Equals(z)，则x.Equals(z)肯定返回true。
        * 必须一致。比较的两个值不变，则返回值不变。
        * 可能还需要做：
            * 让类型实现System.IEquatable<T>接口的Equals方法。来实现类型安全的Equals方法。
            * 重载==和!=操作符。

* **对象哈希码**
    
* 如果定义的对象重写了Equals方法，还应该重写GetHashCode方法。
    
* **dynamic**基元类型
    
    * 使用dynamic类型时，编译器会生产payload代码，在运行时根据dynamic的类型来决定具体执行的操作。
    * 所有的表达式都可以隐式转换成dynamic，也可以从dynaimic转换成其他类型。
    * 加载这些程序集(microsoft.csharp.dll等)和内存消耗会造成性能影响。所以如果只是一两个地方需要动态行为，传统做法(反射、手动类型转换)或许更高效。
    
    
---
### *附注

### C#基元类型和对应的FCL类型
| C#基元类型 | FCL类型 | 符合CLS | 说明 |
| ----------- | --------- | -------- |------ |
| sbyte | System.SByte | 否 | 有符号8位值 |
| byte  | System.Byte   | 是 | 无符号8位值 |
| short | System.Int16 | 是 | 有符号16位值 |
| ushort | System.UInt16 | 否 | 无符号16位值 |
| int | System.Int32 | 是 | 有符号32位值 |
| uint | System.Uint32 | 否 | 无符号32位值 |
| long | System.Int64 | 是 | 有符号64位值 |
| ulong | System.UInt64 | 否 | 无符号64位值 |
| char | System.Char | 是 | 16位Unicode字符 |
| float | System.Single | 是 | IEEE 32位浮点值 |
| double | System.Double | 是 | IEEE 64位浮点值 |
| bool | System.Boolean | 是 | true/false值 |
| decimal | System.Decimal | 是 | 128位高精度浮点值，常用于不容许舍入误差的金融计算。128位中，1位是符号，98位是之本身($N$)，8位是比例因子($k$),decimal实际值是$±N✖10$，其中 $-18<=k<=0$,其余位没有使用 。|
| string | System.String | 是 | 字符数组 |
| object | System.Object | 是 | 所有类型的基类型 |
| dynamic | System.Object | 是 | 对于CLR，denamic和object完全一致。但C#编译器允许使用简单的语法让dynamic变量参与动态调度|