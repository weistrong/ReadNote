## 异常和状态管理

#### 定义异常

> 异常是指成员没有完成它的名称所宣称的行动。



####　异常处理机制

###### `try`

> 如果在一个 try 块中执行多个可能抛出同一个异常类型的操作，但不同的操作有不同的异常恢复措施，就应该将每个操作都放到它自己的 try 块中。

* 如果代码需要执行一般性的资源清理操作，需要从异常中恢复，或者两者都需要。
* 包含可能会抛出异常的代码。

###### `catch`

> 包含的是响应一个异常需要执行的代码。
>
> 一个 try 块可以关联 0 个或者多个 catch 块。
>
> Visual Studio 中调试 catch 块时，可在监视窗口中添加 `$exception` 来查看当前抛出的异常对象。

* 处理异常
  * 一旦 CLR 找到匹配的 catch 块，就会执行内层所有 finally 块中的代码。
  * 然后执行匹配异常的那个 catch 块中的代码，在这里对异常的处理通常有：
    * 重新抛出相同的异常，向调用堆栈高一层的代码通知该异常的发生；
    * 抛出一个不同的异常，向调用堆栈高一层的代码提供更加丰富的异常信息；
    * 让线程从 catch 块的底部退出_(fall out of the bottom of the catch block)_。

###### `finally`

> finally 块包含的是保证会执行的代码。一般在 finally 块中执行 try 块的行动所要求的资源清理操作。
>
> 它必须出现在 catch 块之后，并且一个 try 块最多只能够关联一个 finally 块。
>
> `Exception` 类型能捕捉 _CLS_ 和 _非CLS_异常(_System.Runtime.CompilerServices_)(CLR 2.0 以后)。



#### `System.Exception`

> CLR 允许抛出任何类型的实例，C#编译器只允许抛出 CLS 相容的异常。

###### `StackTrace` 属性

* 包含信息

  * 一个异常抛出时，CLR 在内部记录 throw 指令的位置(抛出位置)。一个 catch 块捕捉到该异常时，CLR 记录捕捉位置。

    在 catch 块内访问被抛出的异常对象的 `StackTrace` 属性，负责实现该属性的代码会调用 CLR 内部的代码。

    后者创建一个字符串来支持**从异常抛出位置到异常捕捉位置**的所有方法。

  * 抛出异常时，CLR 会重置异常起点；也就是说，CLR 只记录最新的异常对象的位置。

* 完整堆栈跟踪。

  * `StackTrace` 属性返回的字符串不包含调用堆栈中比接受异常对象的那个 catch 块高的方法。要获得从线程起始处到异常处理程序_(catch)_之间的完整堆栈跟踪，需要使用 `System.Diagnostics.StackTrace` 类型。
  
  

#### 抛出异常

* 抛出异常时要考虑两个问题：

  * 抛出什么 Exception 派生类型。
    * 要考虑调用栈中位于高出的代码，要知道那些代码如何判断一个方法失败从而执行得体的恢复代码。
  * 向异常类型的构造器传递什么字符串信息。

  

#### 定义自己的异常类

> 从 `Exception` 派生的所有类型都应该时**可序列化**的。



#### 设计规范和最佳实践

###### 善用 `finally` 块。

>  应该先用 `finally` 块清理那些已成功启动的操作，再返回至调用者或者执行 `finally` 块之后的代码。另外，还经常利用 `finally` 块显式释放对象以避免资源泄漏。

* 自动生成 `try/finally` 块的情况：
  * 只要使用了 `lock`、`using` 和 `foreach` 语句，C# 编译器就会自动生成 `try/finally` 块。
  * 重写类的析构器_( Finalize 方法)_ 时，C# 编译器也会自动生成 `try/finally` 块。

###### 不要什么都捕捉。

> 捕捉异常表明你预见到该异常，理解它为什么发生，并知道如何处理它。
>
> 换句话说，是在为应用程序定义一个**策略**。

> 不能完成任务的一个方法检测到对象状态已经损坏，而且状态无法恢复。不应抛出异常，应调用 `System.Environment` 的 `FailFast()` 方法强迫进程终止。

* 如果类型时类库的一部分，那么任何情况下都绝对不允许捕捉并“吞噬”_(自己搞定异常，并当它没有发生)_所有异常。
* 如果要在 `catch` 块中捕捉 `System.Exception` 并执行一些代码，要在 `catch` 块的末尾**重新抛出异常**。( VS 的代码之分析工具_( FxCopCmd.exe )_) 会标记包含 `catch(Exception)` 块的所有代码，除非块中有 `throw` 语句。
* 可以在一个线程中捕捉异常，在另一个线程中重新抛出异常。为此提供支持的是**异步编程模型**。

###### 得体的从异常中恢复

* 有时，调用方法时已预料到它可能抛出某些异常。可以写一些代码，允许应用程序从一场中得体地回复并继续运行。
* 捕捉具体异常时，应充分掌握在什么时候会抛出异常，并知道从捕捉的异常类型派生出了哪些具体类型。不要捕捉并处理 System.Exception，除非你会重新抛出。

###### 发生不可恢复的异常时回滚部分完成的操作-维持状态

* 为了正确回滚已部分完成的操作，代码应捕捉所有异常，并在处理完成后重新抛出。

###### 隐藏实现细节来维系协定

* 有时，需要捕捉一个异常并重新抛出不同的异常。这样做唯一的原因时维系方法的**协定**。

* 抛出的新异常应该是一个具体异常，不能是其他异常类型的基类。

* 如果捕捉一个异常并抛出新异常，目的是在异常类中添加额外的数据或上下文，可以使用:

  * ```C#
    catch(IOException e){
        e.Data.Add("FileName", fileName);
        throw;
    }
    ```
    
  * 好的应用：如果构造器抛出异常，并且该异常未在构造器中捕捉，CLR 会在内部捕捉该异常，并改为抛出 `TypeInitializationException`。
  
  * 坏的应用：通过反射调用方法时，CLR 内部捕捉方法抛出的任何异常，都被转换成 `TargetInvocationException` 。使用 `dynamic` 来调用成员，编译器就不会这样处理，而是正常的在调用栈上向上传递。这是使用 `dynamic` 来代替反射的一个很好的理由。



#### 未处理的异常

> 异常抛出时，CLR 在调用栈中向上查找与抛出的异常对象的类型匹配的 catch 块。没有任何 catch 块匹配抛出的异常类型，就发生一个**未处理的异常**。
>
> CLR 检测到进程中的任何线程有未处理的异常，都会终止进程。WIndows 会向事件日志写一条记录。

> 类库开发人员用不着去想未处理的异常。



#### 异常处理的性能问题

* 和收益相比，异常处理所造成的额外性能开销大于对性能的影响。
* 可使用 Windows 自带的 `性能监视器` 和 随同 .Net Framework 安装的与异常有关的计数器。
* 首先应建立一个最佳的对象模型，只有用户因为抛出异常而对性能不满意时，才在类型中添加 `TryXxx` 方法。



#### 约束执行区域(CER)

> `CER` 是必须对错误有适应力的代码。

* `PrepareConstrainedRegions()` 是一个特别的方法。
  * JIT 编译器如果发现在一个 try 块之前调用了这个方法，就会提前编译与 try 关联的 catch 和 finally 块中的代码。
  * JIT 编译器会加载任何程序集，创建任何类型对象，调用任何静态构造器，并对任何方法进行 JIT 编译。如果任何操作造成异常，会在线程进入 try 块之前发生。
  * JIT 编译器提前准备方法时，还会遍历整个调用图，提前准备被调用的方法，前提是这些方法应用了 `ReliabilityContractAttribute`，而且向这个特性实例的构造器传递的是 `Consistency.WillNotCorruptState` 或 `Consistency.MayCorruptInstance` 枚举成员。
  * 再通过 `PrepareConstrainedRegions` 调用来保护的一个 catch 或 finally 块中，请确保只调用根据刚才的描述设置了 `ReliabilityContractAttribute` 的方法。
* 如何保证方法得以执行：
  * `RuntimeHelper.ExecuteCodeWithGuaranteedCleanUp()`
    * 在资源保证得到清理的前提下才执行代码。
  * `CriticalFinalizeObject`



#### 代码协定

> **代码协定_(code contract)_** 提供了直接在代码中声明代码设计决策的一种方式。
>
> 协定不能在新版本中变得更严格，否则会破坏兼容性。

* 采取形式：
  * 前条件
    * 一半用于对实参进行验证。
  * 后条件
    * 方法因为一次普通的返回或抛出异常而终止时，对状态进行验证。
  * 对象不变性_(Object Invariant)_
    * 在对象的整个生命期内，确保对象的字段的良好状态。

  > 前条件、后条件、对象不变性中引用的任何成员都一定不能有副作用(改变对象的状态)。
  >
  > 前条件测试中引用的所有成员的可访问性都至少要和前条件的方法一样。
  >
  > 涉及继承时，派生类型不能重写并更改基类型中定义的虚成员的前条件。

* 核心是**静态类**：`System.Diagnostics.Contracts.Contract`







